$EMPTY DSLIPOBJ OK
$CON *PRINT* HOLD  ROUTE=NUBS
$RUN W114:CCDSCN PAR=X=W114:LISTING.XECS
$VERLAB DSLIP-BH SLIPLIB
$R *FTN PAR=S=DSLIP.S(16) LO=DSLIPOBJ TEST MAP PRINT=*PRINT*
$SOURCE PREVIOUS
      END
 
 
$CON *PRINT* HOLD  ROUTE=NUBS
$RUN W114:CCDSCN PAR=X=W114:LISTING.XECS
$VERLAB DSLIP-BH SLIPLIB
$RUN W058:LISTER SPRINT=*PRINT* PAR=W081:DSLIP.S(16)
$SOURCE PREVIOUS
      END
      DOUBLE PRECISION FUNCTION ADVLEL(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVLL,F,R
C            ADVLEL(R,F) 
C     THE LPNTR OF THE READER R MOVES  LEFT  (UP)  TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO AN ELEMENT
C     (AN ELEMENT IS A NON-NAME). IF THAT ELEMENT IS NOT A HEADER,F IS 
C     SET TO ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED 
C     THAT ELEMENT. IF THE ELEMENT IS A HEADER, F IS SET TO NONZERO AND 
C     THE VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLL(R,0,0) 
      IF (F.NE.0) GO TO 1 
      ADVLEL = REED(R) 
      RETURN
    1 CONTINUE
      ADVLEL=0.0D0
      RETURN
      END 
      DOUBLE PRECISION FUNCTION ADVLER(R,F) 
      DOUBLE PRECISION REED 
      INTEGER F,ADVLR,R
C            ADVLER(R,F) 
C     THE LPNTR OF THE READER R MOVES RIGHT (DOWN) TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO AN ELEMENT 
C     (AN ELEMENT IS A NON-NAME). IF THAT ELEMENT IS NOT A HEADER,F IS 
C     SET TO ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED 
C     THAT ELEMENT. IF THE ELEMENT IS A HEADER, F IS SET TO NONZERO AND 
C     THE VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLR(R,0,0) 
      IF (F.NE.0) GO TO 1 
      ADVLER = REED(R) 
      RETURN 
  1   CONTINUE
      ADVLER=0.D0
      RETURN
      END 
      FUNCTION ADVLL(LR,J,K) 
      INTEGER ADVLL,R,F
C                                                          4/1/63 
1     CONTINUE
         LK=LNKL(LNKL(LR))
         CALL SETIND(-1,LK,-1,LR)
         ITEMP=ID(LK)
      IF(ITEMP .EQ. 2) GO TO 3
      IF(ITEMP .EQ. J) GO TO 2
      IF(ITEMP .NE. K) GO TO 1
2     ADVLL = 0 
      GO TO 4 
3     ADVLL = -1 
4     CONTINUE
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION ADVLNL(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVLL,F,R
C            ADVLNL(R,F) 
C     THE LPNTR OF THE READER R MOVES  LEFT  (UP)  TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO A NAME. IF 
C     THAT  STOP WAS ACTUALLY MADE AT A NAME AND NOT A HEADER, F IS SET 
C     TO ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED IN 
C     THE NAME.. IF THE STOP WAS MADE AT A HEADER, F IS SET TO NONZERO 
C     AND THE VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLL(R,1,1) 
      IF (F.NE.0) GO TO 1 
      ADVLNL = REED(R) 
      RETURN
    1 CONTINUE
      ADVLNL=0.0D0
      RETURN
      END 
      DOUBLE PRECISION FUNCTION ADVLNR(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVLR,F,R
C            ADVLNR(R,F) 
C     THE LPNTR OF THE READER R MOVES RIGHT (DOWN) TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO A NAME. IF 
C     THAT  STOP WAS ACTUALLY MADE AT A NAME AND NOT A HEADER, F IS SET 
C     TO ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED IN 
C     THE NAME.. IF THE STOP WAS MADE AT A HEADER, F IS SET TO NONZERO 
C     AND THE VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLR(R,1,1) 
      IF (F.NE.0) GO TO 1 
      ADVLNR = REED(R) 
      RETURN
    1 CONTINUE
      ADVLNR=0.0D0
      RETURN
      END 
      FUNCTION ADVLR(LR,J,K) 
      INTEGER ADVLR
1     CONTINUE
         LK=LNKR(LNKL(LR))
      CALL SETIND(-1,LK,-1,LR) 
      ITEMP=ID(LK)
      IF(ITEMP .EQ. 2) GO TO 3 
      IF(ITEMP .EQ. J) GO TO 2 
      IF(ITEMP .NE. K) GO TO 1 
    2 CONTINUE
      ADVLR = 0 
      GO TO 4 
    3 ADVLR = -1 
4     CONTINUE
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION ADVLWL(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVLL,R,F
C            ADVLWL(R,F) 
C     THE LPNTR OF THE READER R MOVES LEFT  (UP)   TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO A WORD (A 
C     WORD IS A NAME OR NONNAME).IF THAT WORD IS NOT A HEADER, F IS SET 
C     TO  ZERO AND THE VALUE FO THE FUNCTION IS THE DATUM CONTAINED IN 
C     THAT WORD. IF THE WORD IS A HEADER, F IS SET TO NONZERO AND THE 
C     VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLL(R,1,0) 
      IF (F.NE.0) GO TO 1 
      ADVLWL = REED(R) 
      RETURN
    1 CONTINUE
      ADVLWL=0.0D0
      RETURN
      END 
      DOUBLE PRECISION FUNCTION ADVLWR(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVLR,R,F
C            ADVLWR(R,F) 
C     THE LPNTR OF THE READER R MOVES RIGHT (DOWN) TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO A WORD (A 
C     WORD IS A NAME OR NONNAME).IF THAT WORD IS NOT A HEADER, F IS SET 
C     TO  ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED IN 
C     THAT WORD. IF THE WORD IS A HEADER, F IS SET TO NONZERO AND THE 
C     VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLR(R,1,0) 
      IF (F.NE.0) GO TO 1 
      ADVLWR = REED(R) 
      RETURN
    1 CONTINUE
      ADVLWR=0.0D0
      RETURN
      END 
      DOUBLE PRECISION FUNCTION ADVSEL(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVSL,R,F
C            ADVSEL(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL LEFT 
C     (UP)    IS CHECKED TO SEE IF IT IS AN ELEMENT (AN ELEMENT IS A 
C     NON-NAME). IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST. THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY. THE NEXT CELL  LEFT  (UP)  IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENT 
C     ED BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F=ADVSL(R,0,0) 
      IF (F.NE.0) GO TO 1 
      ADVSEL = REED(R) 
      RETURN
    1 CONTINUE
      ADVSEL=0.0D0
      RETURN
      END 
      DOUBLE PRECISION FUNCTION ADVSER(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVSR,R,F
C            ADVSER(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL RIGHT 
C     (DOWN)  IS CHECKED TO SEE IF IT IS AN ELEMENT (AN ELEMENT IS A 
C     NON-NAME). IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST. THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY. THE NEXT CELL RIGHT (DOWN) IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENT 
C     ED BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F = ADVSR(R,0,0) 
      IF (F.NE.0) GO TO 1 
      ADVSER = REED(R) 
      RETURN
    1 CONTINUE
      ADVSER=0.0D0
      RETURN
      END 
      FUNCTION ADVSL(LR,J,K)
C...  Recoded by B. Herzog, January 1974.
C...  The coding of J and K
C...  If J=0 and K=0 seeking element - non name
C...     J=1 and K=0 seeking word
C...     J=1 and K=1 seeking name
      INTEGER ADVSL
      ADVSL=0.
C...  Get the cell pointer
      LPTR=LNKL(LR)
C...  Does the initial cell's datum contain a list name?
      IF(ID(LPTR).EQ.1) GO TO 300
C...  No it does not
100   CONTINUE
C...  Proceed to the next left cell; update the list pointer
      LPTR=LNKL(LPTR)
C...  Update the reader
      CALL SETIND(-1,LPTR,-1,LR)
C...  What is the nature of the datum? Test the ID which may be 0, 1 or 2.
      ITEMP=ID(LPTR)
C...  Is the KANDidate cell a header?
      IF(ITEMP.EQ.2) GO TO 200
C...  No it was not a header. Thus ITEMP can only be 0 or 1
C...  Thus if J and K are different word is sought
      IF(J.NE.K) RETURN
C...  So J.EQ.K and if ITEMP.EQ.J more success
      IF(ITEMP.EQ.J) RETURN
      IF(ITEMP.EQ.0) GO TO 100
      GO TO 300
C...
200   CONTINUE
C...  A header has been encountered
C...  Is the reader on the main list? Check its level counter.
C...  If no go, to pop the stack
      IF(LCNTR(LR).NE.0) GO TO 400
C...  It is at the head of the main list. Set flag.
      ADVSL=-1
C...  Take exit
      RETURN
C...
300   CONTINUE
      CALL PSHRDR(LR,LPTR)
      GO TO 100
C...
400   CONTINUE
C...  Ready to pop the reader stack
C...
      CALL POPRDR(LR,LPTR)
      GO TO 100
      END
      SUBROUTINE PSHRDR(LR,LPTR)
      DOUBLE PRECISION LINKWD,DATUM,DTEMP2
C...  The cell does contain the name of a list and a reader is to be appointed to it
C...  The previous reader must be pushed; get a cell.
      M=NUCELL(Z)
C...  Get the datum and linkword of LR; put them into the new cell.
      CALL STLNKW(LINKWD(LR),M)
      CALL STRDAT(DATUM(LR),M)
C...  Now update the active reader
C...  Set the LNKR to point to the new cell
      CALL SETIND(-1,-1,M,LR)
C...  Store the sub-list name's cell address, found in LPTR's datum
C...  in the LNKL.  Count up the level counter and put it back into DTEMP2.
      DTEMP2=DATUM(LR)
      CALL SETDIR(-1,DATUM(LPTR),LCNTR(LR)+1,DTEMP2)
C...  Update the reader's datum
      CALL STRDAT(DTEMP2,LR)
C...  Update LPTR
      LPTR=IDATUM(LPTR)
      RETURN
      END
      SUBROUTINE POPRDR(LR,LPTR)
       DOUBLE PRECISION LINKWD,DATUM
      NEXRDR=LNKR(LR)
C...  Take the linkword and datum of the NEXRDR and place in LR
      CALL STLNKW(LINKWD(NEXRDR),LR)
      CALL STRDAT(DATUM(NEXRDR),LR)
C...  Release the cell NEXRDR
      CALL RCELL(NEXRDR)
      LPTR=LNKL(LR)
      RETURN
      END
      DOUBLE PRECISION FUNCTION ADVSNL(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVSL,R,F
C            ADVSNL(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL LEFT 
C     (UP)    IS CHECKED TO SEE IF IT IS A NAME. 
C                IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST.THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY.THE NEXT CELL  LEFT  (UP)  IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENT 
C     ED BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F = ADVSL(R,1,1) 
      IF (F.NE.0) GO TO 1 
      ADVSNL = REED(R) 
      RETURN
    1 CONTINUE
      ADVSNL=0.0D0
      RETURN
      END 
      DOUBLE PRECISION FUNCTION ADVSNR(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVSR,R,F
C            ADVSNR(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL RIGHT 
C     (DOWN)  IS CHECKED TO SEE IF IT IS A NAME. 
C                IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST. THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY. THE NEXT CELL RIGHT (DOWN) IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENT 
C     ED BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
      F = ADVSR(R,1,1) 
      IF (F.NE.0) GO TO 1 
      ADVSNR = REED(R) 
      RETURN
    1 CONTINUE
      ADVSNR=0.0D0
      RETURN
      END 
      FUNCTION ADVSR(LR,J,K)
C...  Recoded by B. Herzog, January 1974.
C...  The coding of J and K
C...  If J=0 and K=0 seeking element - non name
C...     J=1 and K=0 seeking word
C...     J=1 and K=1 seeking name
      INTEGER ADVSR
      ADVSR=0.
C...  Get the cell pointer
      LPTR=LNKL(LR)
C...  Does the initial cell's datum contain a list name?
      IF(ID(LPTR).EQ.1) GO TO 300
C...  No it does not
100   CONTINUE
C...  Proceed to the next left cell; update the list pointer
      LPTR=LNKR(LPTR)
C...  Update the reader
      CALL SETIND(-1,LPTR,-1,LR)
C...  What is the nature of the datum? Test the ID which may be 0, 1 or 2.
      ITEMP=ID(LPTR)
C...  Is the KANDidate cell a header?
      IF(ITEMP.EQ.2) GO TO 200
C...  No it was not a header. Thus ITEMP can only be 0 or 1
C...  Thus if J and K are different word is sought
      IF(J.NE.K) RETURN
C...  So J.EQ.K and if ITEMP.EQ.J more success
      IF(ITEMP.EQ.J) RETURN
      IF(ITEMP.EQ.0) GO TO 100
      GO TO 300
C...
200   CONTINUE
C...  A header has been encountered
C...  Is the reader on the main list? Check its level counter.
C...  If no go, to pop the stack
      IF(LCNTR(LR).NE.0) GO TO 400
C...  It is at the head of the main list. Set flag.
      ADVSR=-1
C...  Take exit
      RETURN
C...
300   CONTINUE
      CALL PSHRDR(LR,LPTR)
      GO TO 100
C...
400   CONTINUE
C...  Ready to pop the reader stack
C...
      CALL POPRDR(LR,LPTR)
      GO TO 100
      END
      DOUBLE PRECISION FUNCTION ADVSWL(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVSL,R,F
C            ADVSWL(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL LEFT 
C     (UP)    IS CHECKED TO SEE IF IT IS A WORD (A WORD IS A NAME OR A 
C     NON-NAME). IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST. THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY. THE NEXT CELL  LEFT  (UP)  IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENTED 
C     BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F = ADVSL(R,1,0) 
      IF (F.NE.0) GO TO 1 
      ADVSWL = REED(R) 
      RETURN
    1 CONTINUE
      ADVSWL=0.0D0
      RETURN
      END 
      DOUBLE PRECISION FUNCTION ADVSWR(R,F) 
      DOUBLE PRECISION REED 
      INTEGER ADVSR,R,F
C            ADVSWR(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL RIGHT 
C     (DOWN)  IS CHECKED TO SEE IF IT IS A WORD (A WORD IS A NAME OR A 
C     NON-NAME). IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST.THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY.THE NEXT CELL RIGHT (DOWN) IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENTED 
C     BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F = ADVSR(R,1,0) 
      IF (F.NE.0) GO TO 1 
      ADVSWR = REED(R) 
      RETURN
    1 CONTINUE
      ADVSWR=0.0D0
      RETURN
      END 
      DOUBLE PRECISION FUNCTION BOT(L) 
      DOUBLE PRECISION L,LINKWD,LOCT,DATUM 
C            BOT(L) 
C     THE INPUT PARAMETER TO THE FUNCTION BOT IS THE NAME OF A LIST. ITS 
C     VALUE IS THE DATUM STORED ON THE BOTTOM (RIGHTMOST) CELL ON THAT 
C     LIST. THE LIST IS NOT MODIFIED BY THIS OPERATION. 
C                                                          4/1/63 
      BOT=DATUM(LNKL(LOCT(L)))
      RETURN 
      END 
      FUNCTION DELETE(NSC) 
      DOUBLE PRECISION DELETE,DATUM
C            DELETE(NSC) 
C     THE INPUT PARAMETER TO THIS FUNCTION IS THE ADDRESS OF A 
C     LIST CELL. THE LIST CELL SO INDICATED IS DELETED FROM THE LIST ON 
C     WHICH IT APPEARS AND THE DATUM STORED IN THAT CELL DELIVERED AS 
C     THE VALUE OF THE FUNCTION. IF THE ADDRESS OF A LIST HEADER IS 
C     GIVEN AS THE INPUT PARAMETER, THEN THE VALUE OF THE FUNCTION WILL 
C     BE ZERO AND AN ERROR MESSAGE PRINTED. THE PROGRAM WILL CONTINUE TO 
C     BE EXECUTED. 
C                                                          4/1/63 
      DATA IDEV /16/
      IF (ID(NSC).EQ.2) GO TO 9000 
         DELETE = DATUM(NSC) 
         LL = LNKL(NSC) 
         LR = LNKR(NSC) 
         CALL SETIND(-1,-1,LR,LL) 
         CALL SETIND(-1,LL,-1,LR) 
         CALL RCELL(NSC) 
      RETURN 
9000  CONTINUE
         WRITE (6,9010) 
         DELETE = 0.0 
      RETURN 
9010  FORMAT(1H1,/99H AN ATTEMPT HAS BEEN MADE TO DELETE A HEADER - ZERO 
     1 HAS BEEN DELIVERED AND THE PROGRAM CONTINUED.             ) 
      END 
      SUBROUTINE DERROR(LST) 
      DOUBLE PRECISION LST 
C        WRITE (6,900) LST 
      CALL SLPERR(2,LST)
C     WRITE (6,901) 
      RETURN 
900   FORMAT (1H1,20X,A8) 
  901 FORMAT (20X,44HATTRIBUTE-VALUE LIST REQUIRED BUT NOT FOUND ) 
      END 
      FUNCTION INITRD(NRD) 
      DOUBLE PRECISION DATUM
C            INITRD(NRD) 
C     THIS FUNCTION CAUSES THE LPNTR OF THE READER WHICH IS ITS INPUT 
C     PARAMETER TO POINT TO THE HEADER OF THE LIST THE READER IS 
C     CURRENTLY POINTING INTO. THE VALUE OF THE FUNCTION IS THE ADDRESS 
C     OF THE READER. TO COMPLETELY INITIALIZE A READER, THE STATEMENT-- 
C            CALL INITRD(LVLRVT(NRD)) 
C     WOULD BE USED. 
C                                                          4/1/63 
      CALL SETIND(-1,LNKLW(DATUM(NRD)),-1,NRD) 
      INITRD =NRD 
      RETURN 
      END 
      FUNCTION INLSTL(LST,NSC) 
C            INLSTL(LST,NSC) 
      DOUBLE PRECISION INLSTL,LST,LOCT
C     LST MUST BE THE ALIAS OF A LIST AND NSC THE MACHINE ADDRESS OF A LIST 
C     CELL. INLSTL TAKES THE SET OF LINKED CELLS CONSTITUTING THE BODY 
C     OF THE LIST LST,I.E., ALL BUT THE HEADER OF THAT LIST, AND INSERTS 
C     IT TO THE LEFT OF THE CELL NSC. LST IS MADE INTO AN EMPTY LIST AND ITS 
C     NAME DELIVERED AS THE VALUE OF THE FUNCTION. 
C                                                          4/1/63 
         LST = LOCT(LST) 
         ITOP = LNKR(LST) 
         IBOT = LNKL(LST) 
      INLSTL=LST 
C...  Fix up the header of the body less list
      CALL SETIND(-1,LST,LST,LST) 
C...  Get the LNKL of cell NSC
         IPRE = LNKL(NSC) 
C...  Reset the lnkl of cell NSC
      CALL SETIND(-1,IBOT,-1,NSC) 
C...  Reset the LNKR of the cell that previously preceded NSC
      CALL SETIND(-1,-1,ITOP,IPRE) 
C...  Reset the LNKL of the top cell inserted
      CALL SETIND(-1,IPRE,-1,ITOP) 
C...  Reset the LNKR of the bottom cell inserted
      CALL SETIND(-1,-1,NSC,IBOT) 
      RETURN 
      END 
      FUNCTION INLSTR(LST,NSC) 
      DOUBLE PRECISION INLSTR,LST,LOCT
C            INLSTR(LST,NSC) 
C     LST MUST BE THE ALIAS OF A LIST AND NSC THE MACHINE ADDRESS OF A LIST 
C     CELL. INLSTR TAKES THE SET OF LINKED CELLS CONSTITUTING THE BODY 
C     OF THE LIST LST,I.E., ALL BUT THE HEADER OF THAT LIST, AND INSERTS 
C     IT TO THE RIGHT OF THE CELL NSC. LST IS MADE INTO AN EMPTY LIST AND 
C     ITS NAME DELIVERED AS THE VALUE OF THIS FUNCTION. 
C                                                          4/1/63 
         LST=LOCT(LST) 
         ITOP = LNKR(LST) 
         IBOT = LNKL(LST) 
      INLSTR=LST 
      CALL SETIND(-1,LST,LST,LST) 
         ISUC = LNKR(NSC) 
      CALL SETIND(-1,-1,ITOP,NSC) 
      CALL SETIND(-1,IBOT,-1,ISUC) 
      CALL SETIND(-1,NSC,-1,ITOP) 
      CALL SETIND(-1,-1,ISUC,IBOT) 
      RETURN 
      END 
      FUNCTION IRALST(LST) 
      DOUBLE PRECISION DATUM,DATUML,LST
      DATA IDEV/16/
C            IRALST(LST) 
C     THE LIST THE NAME OF WHICH APPEARS AS AN INPUT PARAMETER TO THIS 
C     FUNCTION IS ERASED,I.E., ALL ITS CELLS, INCLUDING ITS HEADER, ARE 
C     RESTORED TO LAVS BY THIS FUNCTION. HOWEVER, THIS LIST (AND ITS 
C     CONTENTS) MAY STILL BE THE SUBLIST OF ANOTHER LIST. THE ERASURE IS 
C     NOT ACTUALLY CARRIED OUT IF THAT CONDITION IS DETECTED. (THE 
C     REFERENCE COUNTER OF THE LIST IS MERELY COUNTED DOWN BY ONE IN 
C     THAT EVENT.) THE VALUE OF THE FUNCTION IS AN INTEGER SPECIFYING 
C     OF HOW MANY LISTS THE SUBJECT LIST IS A SUBLIST. IF THAT VALUE IS 
C     ZERO, THE LIST HAS ACTUALLY BEEN ERASED. 
C                                                          4/1/63 
C...  Extensive changes. B. Herzog, January 1974.
C...  Is the offered LST really a list name?
      IF(NAMTST(LST).NE.0) GO TO 300
C...  It is a proper list name; therefore get its reference counter.
      IRALST=LCNTR(LST)
C...  If that reference counter value is less than or equal to zero already then
C...  something is wrong.
      IF(IRALST.LT.0) GO TO 400
C...  If it is greater than zero:count it down.
      IF (IRALST.GT.0) IRALST=IRALST-1
C...  If the reference counter is now equal to zero, branch to removal sequence.
      IF(IRALST.EQ.0) GO TO 100
C...
C...  Reference counter is still one or greater.
      DATUML=DATUM(LST)
C...  Update the reference counter and return
      CALL SETDIR(-1,-1,IRALST,DATUML)
      CALL STRDAT(DATUML,LST)
      RETURN
C...
C...
100   CONTINUE
C...  The reference counter is zero; so we may return list to LAVS.
C...  First empty the list; i.e., return its cells to LAVS
      CALL MTLIST(LST)
C...  Look at the header. Does it refer to a description list?
      N=LNKLW(DATUM(LST))
      IF(N.EQ.0) GO TO 200
C...  There is a reference to a description list.
C...  Fix up the header cell about to be returned to look like
C...  a cell with a name of a list.
C...  First the ID field is set to 1 for NUCELL
      CALL SETIND(1,0,0,LST)
C...  Now fix the datum to be in list name format for NAMTST
      DATUML=DATUM(LST)
      CALL SETDIR(1,N,N,DATUML)
      CALL SETMKW(6,DATUML)
      CALL STRDAT(DATUML,LST)
C...  Now its all ready to return
200   CONTINUE
      CALL RCELL(LNKRW(LST))
      RETURN
C...
C...
300   CONTINUE
C...  A list name was expected but was not offered
      WRITE(IDEV,910)
      IRALST=0
      RETURN
C...
400   CONTINUE
C...  The reference counter of the offered list is already zero or less
      IRALST=0
      WRITE (IDEV,910)
      WRITE(IDEV,920)
      RETURN
C...
910   FORMAT('0 ATTEMP TO DELETE AN ILL NAMED OR ILL FORMED LIST.',
     .' 0 RETURNED.')
920   FORMAT('0 ATTEMPT TO DELETE A LIST WHOSE USE COUNT IS ZERO'
     .,' OR LESS. 0 RETURNED.')
      END 
      FUNCTION IRARDR(R) 
      INTEGER R
C            IRARDR(R) 
C     THIS FUNCTION ERASES (RESTORES TO LAVS) THE READER WHICH IS ITS 
C     INPUT PARAMETER. THE VALUE OF THE FUNCTION IS THE LCNTR OF THE 
C     READER,I.E., AN INTEGER WHICH INDICATES HOW DEEPLY WITHIN A LIST 
C     STRUCTURE THE ERASED READER WAS POINTING PRIOR TO ITS ERASURE. 
C                                                          4/1/63 
      IRARDR = LCNTR(R) 
         M = R 
    3    N = LNKR(M) 
      IF(ID(M).NE.3) RETURN 
      CALL SETIND (0,-1,-1,M) 
         CALL RCELL(M) 
         IF(N.EQ.0) RETURN 
         M = N 
         GOTO 3 
      END 
      DOUBLE PRECISION FUNCTION ITSVAL(AT,LST) 
      DOUBLE PRECISION LST,DATUM 
      DOUBLE PRECISION AT 
C            ITSVAL(AT,L) 
C     THIS FUNCTION PRODUCES THE VALUE OF THE ATTRIBUTE AT AS STORED ON 
C     THE DESCRIPTION LIST OF THE LIST L AS ITS VALUE. IF THE ATTRIBUTE 
C     CANNOT BE FOUND, THE VALUE OF THE FUNCTION IS ZERO. 
      IF(LNKLW(DATUM(LST)).EQ.0) GO TO 10    
      M = MADATR(AT,LST)    
      IF((M).EQ.(-1)) GO TO 20 
      ITSVAL =   DATUM(LNKR(M)) 
      RETURN 
   10 CALL DERROR(LST) 
20    ITSVAL = 0.D0 
      RETURN 
      END 
      FUNCTION LCNTR(R) 
      DOUBLE PRECISION DATUM 
      INTEGER R
C            LCNTR(R) 
C     THE INPUT PARAMETER R TO THIS FUNCTION IS THE ADDRESS OF A READER 
C     THE VALUE OF THE FUNCTION IS THE LCNTR (LEVEL COUNTER) OF THE 
C     READER, DELIVERED IN THE FORM OF AN INTEGER. 
C                                                          4/1/63 
      LCNTR = LNKRW(DATUM(R)) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION LDATVL(AT,VL,LST) 
      DOUBLE PRECISION AT,VL,LISTAV,LST,DATUM
         IF(LNKLW(DATUM(LST)).EQ.0) LDATVL=LISTAV(LST) 
      CALL NXTRGT(VL,NXTLFT(AT,LNKLW(DATUM(LST) ))) 
      RETURN 
      END 
      FUNCTION LIST(K) 
      DOUBLE PRECISION LIST,LINKWD,K,DTEMP,DATUM
C            LIST(K) 
C     THIS FUNCTION CREATES AN EMPTY LIST AND LEAVES ITS NAME BOTH AS 
C     ITS VALUE AND IN THE CELL K, UNLESS K IS THE INTEGER 9 IN WHICH 
C     CASE THE NAME IS JUST THE VALUE OF THE FUNCTION. THE CELL K 
C     THUS BECOMES AN ALIAS FOR THE LIST UNLESS IT WAS A 9. TWO ALIASES 
C     MAY BE ESTABLISHED AT ONCE BY WRITING, FOR EXAMPLE, 
C            LA= LIST(LB) 
C     WHICH CAUSES BOTH LA AND LB TO CONTAIN THE NAME OF THE CREATED 
C     LIST. UNLESS K IS THE LITERAL 9, THE REFERENCE COUNTER (NUMBER OF 
C     LISTS FOR WHICH THIS LIST IS A SUBLIST) WILL BE SET TO ONE INITIAL 
C     LY. THUS IT WILL NEVER BE INADVERTANTLY ERASED. IF K IS A 9,  THE 
C     REFERENCE COUNTER IS SET TO ZERO. 
C                                                          4/1/63 
C...  Obtain a cell
      NSC=NUCELL(Z) 
C... Fix up the link word as a header
      CALL SETIND(2,NSC,NSC,NSC) 
      CALL SETMRK(6,NSC) 
C...  Fix up a SLIP name
      LIST=LINKWD(NSC)
      CALL SETDIR(1,-1,-1,LIST)
C...  Now fix the DATUM  of the header.
      IF (INTGER(K).EQ.9) GO TO 1000
      DTEMP = DATUM(NSC)
      CALL SETDIR(-1,-1,1,DTEMP)
      CALL STRDAT(DTEMP,NSC)
      K = LIST 
1000  CONTINUE
      RETURN 
      END 
      FUNCTION LISTAV(LST) 
      DOUBLE PRECISION DTEMP,LISTAV,LIST,SETDIR,DATUM,LST
      DATA IDEV /16/
      LISTAV=LIST(9) 
      IF(NAMTST(LST).NE.0) WRITE(IDEV,901)
C     DTEMP = DATUM(LST)
C     CALL SETDIR(-1,LNKR(LISTAV),-1,DTEMP)
C     CALL STRDAT(DTEMP,LST)
      CALL STRDAT(SETDIR(-1,LNKR(LISTAV),-1,DATUM(LST)),LST)
      RETURN 
 901  FORMAT('  ERROR IN LISTAV: THE ARGUMENT GIVEN IS NOT A LIST ****')
      END 
      FUNCTION LISTMT(P) 
      DOUBLE PRECISION L,LOCT,P,LINKWD
C            LISTMT(L) 
C     THE INPUT PARAMETER TO THIS FUNCTION IS THE NAME OF A LIST. IF 
C     THAT LIST IS EMPTY, THE VALUE OF THE FUNCTION IS ZERO, OTHERWISE 
C     THE FUNCTION HAS A NONZERO VALUE. 
C                                                          4/1/63 
      LISTMT = 0 
      L = LOCT(P) 
      IF (LINKWD(L).NE.LINKWD(LNKR(L))) LISTMT=-1 
       RETURN 
      END 
      FUNCTION LOCT(K) 
      DOUBLE PRECISION LOCT,K
      DATA IDEV /16/
C                                                          4/1/63 
      IF(NAMTST(K).NE.0) GO TO 1000 
      LOCT = K 
      RETURN 
C
1000  CONTINUE
      WRITE (IDEV,9000) 
9000  FORMAT(1H1,/'  A LIST WAS REQUIRED AS AN OPERAND BUT WAS NOT' 
     .,' FOUND  THE PROGRAM WAS REGRETFULLY TERMINATED.') 
      CALL F4TRBK 
      END 
      DOUBLE PRECISION FUNCTION LOFRDR(K) 
      DOUBLE PRECISION DATUM 
C            LOFRDR(R) 
C     THE INPUT PARAMETER R TO THIS FUNCTION IS THE ADDRESS OF A READER. 
C     THE VALUE OF THE FUNCTION IS THE NAME OF THE LIST WHICH THE READER 
C     R IS CURRENTLY READING.THIS VALUE IS DELIVERED IN NAME FORMAT. 
C                                                          4/1/63 
      L = LNKLW(DATUM(K)) 
      CALL SETDIR(1,L,L,LOFRDR) 
      CALL SETMKW(6,LOFRDR) 
      RETURN 
      END 
      FUNCTION LPNTR(K) 
      DOUBLE PRECISION CONT 
C            LPNTR(R) 
C     THE INPUT PARAMETER TO THE LPNTR FUNCTION IS THE ADDRESS OF A 
C     READER. THE VALUE OF THE FUNCTION IS THE MACHINE ADDRESS STORED IN 
C     THE LPNTR FIELD OF THAT READER,I.E., THE ADDRESS OF THE CELL TO 
C     WHICH THAT READER IS CURRENTLY POINTING. 
C                                                          4/1/63 
      LPNTR = LNKL(K) 
      RETURN 
      END 
      FUNCTION LPURGE(LST) 
      DOUBLE PRECISION J,LST,K,X,ADVSWR,ADVLWR,L 
C                                                          4/1/63 
      K = LRDROV(LST) 
         LPURGE = 0 
    3 X = ADVSWR(K,J) 
    6    IF(J)2,1,2 
    1 IF (NAMTST(X))3,4,3 
    4 IF (LSTPRO(X,K))3,5,3 
    5    L = LPNTR(K) 
      X = ADVLWR(K,J) 
      CALL DELETE(L) 
         LPURGE = LPURGE+1 
      GOTO 6 
    2 CALL IRARDR(K) 
      RETURN 
      END 
      FUNCTION LRDRCP(K) 
      DOUBLE PRECISION CONT,DATUM 
C            LRDRCP(R) 
C     THE OBJECTIVE OF THIS FUNCTION IS TO MAKE A COPY OF THE READER 
C     WHICH IS ITS INPUT PARAMETER AND TO DELIVER THE ADDRESS OF THAT 
C     COPY AS ITS VALUE.THE COPY PRODUCED BY THIS FUNCTION MAY BE 
C     ADVANCED AS IF IT WERE THE ORIGINAL READER. 
C                                                          4/1/63 
         LRDRCP = NUCELL(Z) 
         NEWR = LRDRCP 
         NOW = K 
1     CONTINUE
      CALL STLNKW(LINKWD(NOW),NEWR)
      CALL STRDAT(DATUM(NOW),NEWR) 
         NOW = LNKR(NOW) 
           IF (NOW.EQ.0) GO TO 2 
        NEW = NUCELL(Z) 
      CALL SETIND(-1,-1,NEW,NEWR) 
         NEWR = NEW 
         GO TO 1 
    2 RETURN 
      END 
      FUNCTION LRDROV(L) 
      DOUBLE PRECISION L,LOCT,DTEMP 
C            LRDROV(P) 
C     THIS FUNCTION APPOINTS A READER FOR THE LIST WHOSE ALIAS IS GIVEN 
C     AS ITS INPUT PARAMETER. THE VALUE OF THE FUNCTION IS THE ADDRESS 
C     OF THE CELL TAKEN FROM LAVS,I.E., THE CELL WHICH WAS ACTUALLY PUT 
C     IN THE FORMAT OF A READER. IN ITS INITIAL STATE, THE READER IS 
C     POINTING AT THE HEADER OF THE LIST FOR WHICH IT WAS CREATED. 
C                                                          4/1/63 
      LRDROV = NUCELL(Z) 
      CALL SETIND(3,LOCT(L),0,LRDROV) 
      DTEMP=0.0D0
      CALL SETDIR(0,L,0,DTEMP)
      CALL STRDAT(DTEMP,LRDROV)
      RETURN 
      END 
      FUNCTION LSSCPY(LSTORG)
      DOUBLE PRECISION LSTORG,NEWLST,DATM,SUBLST,A,W,REED
      DOUBLE PRECISION LSSCPY,VISIT,LIST,PARMT2,ADVLWR,RESTOR,TOP
      INTEGER READER,DATTYP
      COMMON/PUBLIC/W(10)
C...  The input parameter to this function is a list name.   The 
C...  objective of this function is to create a list, the name of which
C...  is the value of the function, such that the newly created list
C...  is a copy of the input list or list structure.
      DATTYP=0
      ASSIGN 100 TO L100
      READER=LRDROV(LSTORG)
      NEWLST=0.0D0
      NEWLST=LIST(NEWLST)
      LSSCPY=VISIT(L100,PARMT2(READER,NEWLST))
      RETURN
C...  Two stacks are maintained;  the top of the first, W(1), holds
C...  name of the reader appointed to the list or sublist being copied.
C...  The top of the second stack, W(2), holds the name of the list,
C...  or sublist, currently being created and filled.
C...
C...  Begin Loop.
100   CONTINUE
         READER=INTGER(TOP(W(1)))
         NEWLST=TOP(W(2))
200      CONTINUE
C...        Advance the reader.
            DATM=ADVLWR(READER,IFLAG)
            DATTYP=NAMTST(DATM)
C...        Has the reader advanced to the HEADER?
            IF(IFLAG.EQ.0) GO TO 300
C...           A HEADER has been encountered
               CALL IRARDR(READER)
C...           Pop the stacks via TERM
               CALL TERM(NEWLST,RESTOR(2))
C...           That's the end of the recursive loop. TERM returns 
C...           control to the most recent "VISITed" plus 1.
               GO TO 400
300         CONTINUE 
C              If DATM is a list name a sub-list 
C              must be created.
               IF (DATTYP.EQ.0) DATM=LIST(9) 
               CALL NEWBOT(DATM,NEWLST) 
C              Now push the stacks via VISIT if a sub-list.
               IF (DATTYP.EQ.0) CALL VISIT(L100, 
     .                     PARMT2(LRDROV(REED(READER)),DATM))
               GO TO 400 
400         CONTINUE
500      CONTINUE
         IF ((IFLAG.EQ.0).AND.(DATTYP.NE.0)) GO TO 200 
600   CONTINUE 
      IF ((IFLAG.EQ.-1).OR.(DATTYP.EQ.0)) GO TO 100 
      END
      FUNCTION LSTEQL(LISTA,LISTB) 
      DOUBLE PRECISION PARMT2,TOP,ADVLWR,REALL
      DOUBLE PRECISION A,W,LISTA,LISTB,DATUMA,DATUMB 
      INTEGER VISIT,READLA,READLB
      COMMON/PUBLIC/W(10)
C 
C...  Recoded by B. Herzog, May 1974.
C 
C      The two input parameters to this function are both 
C      names of list structures. The objective of this 
C      function is to determine whether or not these 
C      list structures are equal. If they are, the value 
C      of the function is zero, otherwise it is nonzero. 
C      The two list structures are equal if they have 
C      identical structures, i.e., sublist names 
C      appearing in corresponding places within both 
C      structures, and if corresponding elements 
C      appearing in both structures are identical. 
C 
      LSTEQL=0
      ASSIGN 100 TO L100
      LSTEQL=VISIT(L100,PARMT2(LRDROV(LISTA),LRDROV(LISTB))) 
      RETURN 
100   CONTINUE
         READLA=INTGER(TOP(W(1))) 
         READLB=INTGER(TOP(W(2))) 
C...
200   CONTINUE 
      IF (LSTEQL.NE.0) GO TO 800
C...     Advance the readers on both lists.
         DATUMA=ADVLWR(READLA,IFLAGA) 
         DATUMB=ADVLWR(READLB,IFLAGB) 
C...     Inquire if the structures are the same.
C...     IFLAGA or IFLAGB will be non-zero if a HEADER 
C...     is encountered on the corresponding list.
         IF (IFLAGA.NE.IFLAGB) GO TO 600
C...        So the structures are the same. Do the readers 
C...        returned to the HEADER?
            IF (IFLAGA.NE.0) GO TO 500
C...           No. Now examine the DATUM returned from each list. 
C...           Are they list names?
C...           NAMTST yields zero if Datum is name of a list.
               IF ((NAMTST(DATUMA).EQ.0)
     .                   .AND.(NAMTST(DATUMB).EQ.0)) GO TO 300
C...              Not list names! But does DATUMA.EQ.DATUMB? 
                  IF (DATUMA.NE.DATUMB) LSTEQL=-1 
                  GO TO 400 
300            CONTINUE
C...              So both are list names; keep advancing. 
                  CALL PARMT2(LRDROV(DATUMA),LRDROV(DATUMB)) 
                  LSTEQL=VISIT(L100) 
                  IF (LSTEQL.EQ.0) GO TO 100
                  GO TO 400
400            CONTINUE
500         CONTINUE
            GO TO 700
600         CONTINUE
C...        Arrive here if the list structures are not equal.
            LSTEQL=-1
            GO TO 700
700      CONTINUE
800   CONTINUE
      IF ((LSTEQL.EQ.0).AND.(IFLAGA.EQ.0)) GO TO 900
C....
         CALL IRARDR(TOP(W(1))) 
         CALL IRARDR(TOP(W(2))) 
         CALL TERM(REALL(LSTEQL),RESTOR(2)) 
900      CONTINUE
      GO TO 200
      END 
      FUNCTION LSTMRK(LST) 
      DOUBLE PRECISION LST,LOCT,DATUM 
C            LSTMRK(L) 
C     THE INPUT PARAMETER TO THIS FUNCTION IS THE NAME OF THE LIST L. 
C     ITS VALUE IS THE MARK ON THAT LIST. 
         LSTMRK = IDW(DATUM(LOCT(LST))) 
      RETURN 
      END 
      FUNCTION LSTPRO(L,NEXT) 
      DOUBLE PRECISION L,DATUM 
C                                                          4/1/63 
 1   IF(LNKLW(DATUM(NEXT)).EQ.LNKRW(L)) GO TO 2 
      NEXT = LNKR(NEXT) 
      IF(NEXT.EQ.0) GO TO 1
      LSTPRO=-1
      RETURN 
2     LSTPRO = 0 
      RETURN 
      END 
      FUNCTION LVLRV1(LRD) 
      DOUBLE PRECISION LINKWD,DATUM 
      DOUBLE PRECISION DATUM 
C          LVLRV1(LRD) 
C     THE OBJECTIVE OF THIS FUNCTION IS TO CAUSE THE READER LRD TO ASCEND 
C     (REVERSE) ONE LEVEL IN THE LIST STRUCTURE INTO WHICH IT IS 
C     IS LEFT POINTING TO THAT CELL IN THE NEXT HIGHER LIST WHICH 
C     CONTAINS THE NAME OF THE SUBSTRUCTURE INTO WHICH THE READER WAS 
C     CURRENTLY POINTING. IF THE READER IS ALREADY POINTING TO WITHIN 
C     THE MAIN LIST, NOTHING HAPPENS. OTHERWISE, THE LPNTR OF THE READER 
C     POINTING WHEN THE OPERATION WAS INITIATED. THE VALUE OF THE 
C     FUNCTION IS THE ADDRESS OF THE READER. 
C                                                          4/1/63 
         LVLRV1 = LRD 
      IF (LNKR(DATUM(LRD)).EQ.0) RETURN 
      L = LNKR(LRD) 
      CALL STLNKW(LINKWD(L),LRD)
      CALL STRDAT(DATUM(L),LRD)
      CALL    RCELL(L) 
      RETURN 
      END 
      FUNCTION LVLRVT(LRD) 
      DOUBLE PRECISION DATUM ,LINKWD
C            LVLRVT(LRD) 
C     THE OBJECTIVE OF THIS FUNCTION IS TO CAUSE THE READER WHICH IS ITS 
C     INPUT PARAMETER TO ASCEND (REVERSE) IN THE LIST STRUCTURE INTO 
C     WHICH IT IS CURRENTLY POINTING UNTIL IT IS AGAIN POINTING INTO THE 
C     (MAIN) LIST FOR WHICH IT WAS ORIGINALLY APPOINTED. IF THE READER 
C     IS ALREADY POINTING TO WITHIN THE MAIN LIST, NOTHING HAPPENS. 
C     OTHERWISE, THE LPNTR OF THE READER IS LEFT POINTING TO THAT CELL 
C     IN THE MAIN LIST WHICH CONTAINS THE NAME OF THE SUBSTRUCTURE INTO 
C     WHICH THE READER WAS POINTING WHEN THIS OPERATION WAS INITIATED. 
C     THE VALUE OF THE FUNCTION IS THE ADDRESS OF THE READER. THUS, THIS 
C     FUNCTION MAY SERVE AS THE INPUT PARAMETER TO ANY OTHER FUNCTION RE 
C     QUIRING A READER AS ONE OF ITS PARAMETERS. 
C                                                          4/1/63 
         LVLRVT = LRD 
    1    IF (LNKR(DATUM(LRD)).EQ.0) RETURN 
      L=LNKR(LRD) 
      CALL STLNKW(LINKWD(L),LRD)
      CALL STRDAT(DATUM(L),LVLRVT)
      CALL    RCELL(L) 
      GOTO 1 
      END 
      FUNCTION MADATR(AT,LST) 
      DOUBLE PRECISION AT,LST,CONT,EQUAL 
      DOUBLE PRECISION DATUM 
      LSTDES = LNKLW(DATUM(LST)) 
      IF(LSTDES.EQ.0) GO TO 20
      MADATR = LNKR(LSTDES) 
   10 IF(ID(MADATR).EQ.2) GO TO 20
      IF(DATUM(MADATR).EQ.AT) RETURN
      M = LNKR(MADATR) 
         IF (ID(M).EQ.2) GO TO 20 
      MADATR = LNKR(M) 
         GO TO 10 
20    MADATR = -1 
      RETURN 
      END 
      FUNCTION MADLFT(K) 
      DOUBLE PRECISION CONT,DTEMP,MADLFT 
      INTEGER CADLFT,FLAG,ITEMP
      EQUIVALENCE(DTEMP,ITEMP)
C            MADLFT(A) 
C     THE INPUT PARAMETER A TO THIS FUNCTION IS THE MACHINE ADDRESS OF A 
C     LIST CELL OR A HEADER. THE VALUE OF THE FUNCTION IS THE MACHINE AD 
C     DRESS OF THE CELL TO THE LEFT OF (ABOVE) THAT BEING SPECIFIED BY 
C     A. IF THAT MACHINE ADDRESS SHOULD TURN OUT TO BE A HEADER, THEN 
C     THE VALUE WILL BE DELIVERED IN THE FORMAT OF A LIST NAME, 
C     OTHERWISE AS AN INTEGER 
C                                                          4/1/63 
C...
C...  A NEW ENTRY HAS BEEN ADDED BY B. HERZOG, NOVEMBER 1973
C...
      ENTRY CADLFT(K,FLAG)
      FLAG=0
      ITEMP = LNKL((K)) 
      CADLFT=ITEMP
      IF(ID.EQ.2) GO TO 100
C...  THE CELL IS NOT A HEADER
      MADLFT=DTEMP
      RETURN
C...
100   CONTINUE
C...  THE OBTAINED CELL IS A HEADER
      FLAG=-1
      CALL SETDIR(1,ITEMP,ITEMP,MADLFT) 
      CALL SETMKW(6,MADLFT) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION MADNBT(/LSTNAM/,N) 
      DOUBLE PRECISION LSTNAM,SETDIR,DDUM
      INTEGER CADNBT,FLAG,SETMKW
      DIMENSION IDUM(2)
      EQUIVALENCE (DDUM,IDUM(1))
      DATA IDUM /0,0/
C            MADNBT(L,N) 
C     THE INPUT PARAMETERS TO THIS FUNCTION ARETHE NAME OF A LIST LSTNAM, AND 
C     AN INTEGER N. THE OBJECTIVE OF THIS FUNCTION IS TO DELIVER THE 
C     ADDRESS OF THE NTH LIST CELL FROM THE BOTTOM OF THE LIST 
C     LSTNAM. IF THAT CELL IS THE HEADER OF THE LIST LSTNAM, THEN THE VALUE IS 
C     DELIVERED IN THE FORMAT OF THE LIST NAME LSTNAM, OTHERWISE THE VALUE IS 
C     AN INTEGER. IF N IS GREATER THAN THE NUMBER OF CELLS ON THE LIST LSTNAM
C     (INCLUDING THE HEADER CELL), THEN THE EFFECT OF THIS  FUNCTION IS 
C     AS IF N MODULO M HAD BEEN THE SECOND INPUT PARAMETER, WHERE M IS 
C     THE ACTUAL NUMBER OF CELLS (INCLUDING THE HEADER) ON THE LIST L. 
C                                                          4/1/63 
C
C..   Reprogrammed to use CADNBT by B. Herzog, December 1975.
      IDUM(1)=CADNBT(LSTNAM,N,FLAG)
      MADNBT=DDUM
      IF (FLAG.EQ.0) RETURN
      MADNBT=SETDIR(1,IDUM(1),IDUM(1),MADNBT) 
      IDUM(1)=SETMKW(6,MADNBT) 
      RETURN 
      END 
      INTEGER FUNCTION CADNBT(/LSTNAM/,N,FLAG)
      DOUBLE PRECISION LSTNAM,LOCT
      INTEGER CADR,FLAG
      FLAG=0
      CADR=LNKLW(LOCT(LSTNAM))
      DO 100 I=1,N
         CADR=LNKL(CADR)
100   CONTINUE
      CADNBT=CADR
      IF(ID(CADR).EQ.2) FLAG=-1
      RETURN
      END
      DOUBLE PRECISION FUNCTION MADNTP(/LSTNAM/,N) 
      DOUBLE PRECISION LSTNAM,SETDIR,DDUM
      INTEGER CADNTP,FLAG,SETMKW
      DIMENSION IDUM(2)
      EQUIVALENCE (DDUM,IDUM(1))
      DATA IDUM /0,0/
C            MADNTP(L,N) 
C     THE INPUT PARAMETERS TO THIS FUNCTION ARETHE NAME OF A LIST LSTNAM, AND 
C     AN INTEGER N. THE OBJECTIVE OF THIS FUNCTION IS TO DELIVER THE 
C     ADDRESS OF THE NTH LIST CELL FROM THE TOP OF THE LIST 
C     LSTNAM. IF THAT CELL IS THE HEADER OF THE LIST LSTNAM, THEN THE VALUE IS 
C     DELIVERED IN THE FORMAT OF THE LIST NAME LSTNAM, OTHERWISE THE VALUE IS 
C     AN INTEGER. IF N IS GREATER THAN THE NUMBER OF CELLS ON THE LIST LSTNAM
C     (INCLUDING THE HEADER CELL), THEN THE EFFECT OF THIS  FUNCTION IS 
C     AS IF N MODULO M HAD BEEN THE SECOND INPUT PARAMETER, WHERE M IS 
C     THE ACTUAL NUMBER OF CELLS (INCLUDING THE HEADER) ON THE LIST L. 
C                                                          4/1/63 
C
C..   Reprogrammed to use CADNTP by B. Herzog, December 1975.
      IDUM(1)=CADNTP(LSTNAM,N,FLAG)
      MADNTP=DDUM
      IF (FLAG.EQ.0) RETURN
      MADNTP=SETDIR(1,IDUM(1),IDUM(1),MADNTP) 
      IDUM(1)=SETMKW(6,MADNTP) 
      RETURN 
      END 
      INTEGER FUNCTION CADNTP(/LSTNAM/,N,FLAG)
      DOUBLE PRECISION LSTNAM,LOCT
      INTEGER CADR,FLAG
      FLAG=0
      CADR=LNKRW(LOCT(LSTNAM))
      DO 100 I=1,N
         CADR=LNKR(CADR)
100   CONTINUE
      CADNTP=CADR
      IF(ID(CADR).EQ.2) FLAG=-1
      RETURN
      END
      FUNCTION MADRGT(K) 
      DOUBLE PRECISION DTEMP,MADRGT 
      INTEGER CADRGT,FLAG,ITEMP
      EQUIVALENCE(DTEMP,ITEMP)
C            MADRGT(A) 
C     THE INPUT PARAMETER A TO THIS FUNCTION IS THE MACHINE ADDRESS OF A 
C     LIST CELL OR A HEADER. THE VALUE OF THE FUNCTION IS THE MACHINE 
C     ADDRESS OF THE CELL TO THE RIGHT OF (BELOW) THAT BEING SPECIFIED 
C     BY A.  IF THAT MACHINE ADDRESS SHOULD TURN OUT TO BE THAT OF A 
C     HEADER, THEN THE VALUE WILL BE RETURNED IN THE FORMAT OF A NAME, 
C     OTHERWISE AS AN INTEGER. 
C                                                          4/1/63 
C...
C...  A NEW ENTRY HAS BEEN ADDED BY B. HERZOG, NOVEMBER 1973
C...
      ENTRY CADRGT(K,FLAG)
      FLAG=0
      ITEMP = LNKR(K) 
      CADRGT=ITEMP
      IF(ID(ITEMP).EQ.2) GO TO 100
C...  THE CELL IS NOT A HEADER
      MADRGT=DTEMP
      RETURN
C...
100   CONTINUE
C...  THE OBTAINED CELL IS A HEADER
      FLAG=-1
      CALL SETDIR(1,ITEMP,ITEMP,MADRGT) 
      CALL SETMKW(6,MADRGT) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION MAKEDL(L,M) 
      DOUBLE PRECISION L,M,LOCT,DTEMP,DATUM ,N,K
C            MAKEDL(L,M) 
C     THIS FUNCTION MAKES THE LIST L A DESCRIPTION LIST OF THE LIST M. 
C     THE VALUE OF THE FUNCTION IS THE NAME OF THE LIST M. 
      CALL MTDLST(M) 
      MAKEDL = M 
      N= LOCT(M) 
      K= LOCT(L) 
      DTEMP=DATUM(N)
      CALL SETDIR(-1,K,-1,DTEMP)
      CALL STRDAT(DTEMP,N)
      DTEMP=DATUM(K)
      CALL SETDIR(-1,-1,LCNTR(L)+1,DTEMP)
      CALL STRDAT(DTEMP,K)
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION MRKLSS(M,LST) 
      DOUBLE PRECISION LST,MRKLST,LR,ADVSNR,X,DTEMP,DATUM 
C            MRKLSS(M,L) 
C     THE OBJECTIVE OF MRKLSS IS TO PLACE THE MARK 0,1,2, OR 3 ON EVERY 
C     LIST OF THE LIST STRUCTURE L. IN THE SENSE OF THIS FUNCTION, ALL 
C     LISTS ARE MARKED WITH 0 INITIALLY. THE VALUE OF THE FUNCTION IS 
C     THE NAME OF THE LIST L, I.E., THE SECOND INPUT PARAMETER. 
      MRKLSS = LST 
      LR = LRDROV(MRKLST(M,LST)) 
    3    X = ADVSNR(LR,K) 
         IF(K.NE.0) GO TO 1 
      DTEMP=DATUM(LNKRW(X))
      CALL SETDIR(M,-1,-1,DTEMP)
      CALL STRDAT(DTEMP,LNKRW(X))
      GOTO 3 
    1 CALL RCELL(LR) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION MRKLST(M,LST) 
      DOUBLE PRECISION LST,LOCT,DTEMP,DATUM 
C            MRKLST(M,L) 
C     THE OBJECTIVE OF MRKLST IS TO PLACE THE MARK 0,1,2,OR 3 ON THE 
C     LIST L. IN THE SENSE OF THIS FUNCTION ALL LISTS ARE MARKED WITH 
C     ZERO INITIALLY. THE VALUE OF THIS FUNCTION IS THE NAME OF THE LIST 
C     L,I.E., THE SECOND INPUT PARAMETER. 
      MRKLST = LST 
      ITEMP=LNKRW(LOCT(LST))
      DTEMP=DATUM(ITEMP)
      CALL SETDIR(M,-1,-1,DTEMP)
      CALL STRDAT(DTEMP,ITEMP)
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION MTDLST(LST) 
      DOUBLE PRECISION LST,X,LOCT ,DATUM
C            MTDLST(L) 
C     THIS FUNCTION EMPTIES THE DESCRIPTION LIST OF THE LIST L. ITS 
C     VALUE IS THE NAME OF THE LIST L. 
         MTDLST = LST 
      K=LNKLW(DATUM(LOCT(LST))) 
         IF(K.EQ.0) RETURN 
C...  Now fix up a word to look like a list name for MTLIST
      CALL SETDIR(1,K,K,X) 
      CALL SETMKW(6,X) 
      CALL MTLIST(X) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION MTLIST(P) 
      DOUBLE PRECISION M,LOCT,P 
      COMMON/SLIPC1/  FAVSLC,LAVSLC 
      INTEGER FAVSLC
C            MTLIST(L) 
C     THE LIST THE NAME OF WHICH APPEARS AS AN INPUT PARAMETER TO THIS 
C     FUNCTION IS EMPTIED, I.E., ITS CELLS RESTORED TO LAVS. THE VALUE 
C     OF THE FUNCTION IS THE NAME OF THE EMPTY LIST L. 
C     WHEN A LIST IS TO BE RESTORED TO LAVS, THE CELL PRESENTLY ON THE 
C     BOTTOM OF LAVS IS MADE TO POINT TO THE TOP OF THE LIST BEING 
C     ERASED, THE BOTTOM CELL OF THAT LIST IS GIVEN THE APPEARANCE OF A 
C     BOTTOM CELL OF LAVS, AND THE BOTTOM POINTER OF AVSL,I.E., ITS LNKL 
C     FIELD, IS SET TO POINT TO THAT BOTTOM CELL. 
C                                                          4/1/63 
         M = LOCT(P) 
         IF (LISTMT(P).EQ.0) GO TO 1 
C...  Get the LNKL and LNKR of the header
         NSCTOP = LNKR(M) 
         NSCBOT = LNKL(M) 
C...  Set the header for an empty list header
         CALL SETIND(-1,M,M,M) 
C...  Now link the released cells on LAVS
         CALL SETIND(-1,-1,NSCTOP,LAVSLC) 
      LAVSLC=NSCBOT
         CALL SETIND(-1,-1,0,LAVSLC) 
    1    MTLIST = M 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION NAMEDL(L) 
      DOUBLE PRECISION L,LOCT,DATUM
C            NAMEDL(L) 
C     THE VALUE OF THIS FUNCTION IS THE NAME OF THE DESCRIPTION LIST OF 
C     THE LIST L WHICH IS ITS INPUT PARAMETER. 
C...  Get the address of the description list
      LL=LNKLW(DATUM(LOCT(L))) 
C...  Fix up NAMEDL so that its content is in list name format
      CALL SETDIR(1,LL,LL,NAMEDL) 
      CALL SETMKW(6,NAMEDL) 
      RETURN 
      END 
      FUNCTION NAMTST(NAME) 
      DOUBLE PRECISION NAME
C            NAMTST(NAME) 
C     THE DATUM NAME IS EXAMINED. IF IT IS THE NAME OF A LIST, THE VALUE OF 
C     THE FUNCTION IS ZERO, OTHERWISE THE VALUE OF THE FUNCTION IS 
C     NONZERO. 
C                                                          4/1/63 
      IF (LNKLW(NAME).NE.LNKRW(NAME)) GO TO 1000 
      IF(IDW(NAME).NE.1) GO TO 1000
      IF (MRKW(NAME) .NE. 6) GO TO 1000 
      IF (ID(NAME).NE.2) GO TO 1000 
      LINK=LNKR(NAME)
C      CHECK TO SEE IF THIS CELL IS AT THE END OF THE AVSL; THEN LINK=0.
       IF(LINK.EQ.0) GO TO 1000
      IF(LNKR(LNKL(NAME)).NE.LNKL(LNKR(NAME))) GO TO 1000
      NAMTST = 0 
        RETURN 
1000  CONTINUE
      NAMTST = -1 
        RETURN 
      END 
      FUNCTION NEWBOT(P,Q) 
      DOUBLE PRECISION P,Q,LOCT 
C            NEWBOT(P,Q) 
C     NEWBOT PUSHES THE DATUM P UP ON THE BOTTOM OF THE LIST Q. ITS VALU 
C     IS THE MACHINE ADDRESS OF THE CELL TAKEN FROM LAVS FOR THE STORAGE 
C     OF THE DATUM AND THE ASSOCIATED LINKING INFORMATION. 
C                                                          4/1/63 
         NEWBOT = NXTLFT(P,LOCT(Q)) 
      RETURN 
      END 
      FUNCTION NEWTOP(P,Q) 
      DOUBLE PRECISION P,Q,LOCT 
C            NEWTOP(P,Q) 
C     NEWTOP PUSHES THE DATUM P DOWN ON TOP OF THE LIST Q. ITS VALUE IS 
C     THE MACHINE ADDRESS OF THE CELL TAKEN FROM LAVS FOR THE STORAGE OF 
C     THE DATUM AND THE ASSOCIATED LINKING INFORMATION. 
C                                                          4/1/63 
         NEWTOP = NXTRGT(P,LOCT(Q)) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION NEWVAL(AT,VAL,LST) 
      DOUBLE PRECISION VAL,AT 
      DOUBLE PRECISION LST,SUBST,CONT 
C            NEWVAL(AT,VAL,L) 
C     THE OBJECTIVE OF THIS FUNCTION IS TO ASSIGN THE VALUE VAL TO THE 
C     ATTRIBUTE AT ON THE DESCRIPTION LIST OF THE LIST L. VAL REPLACES 
C     WHATEVER THE PREVIOUS VALUE OF AT MAY HAVE BEEN. IF THE ATTRIBUTE 
C     AT CANNOT BE FOUND, IT IS ADDED (TOGETHER WITH ITS VALUE) TO THE 
C     DESCRIPTION LIST. IF NO DESCRIPTION LIST FOR THE LIST L EXISTS, 
C     ONE IS CREATED BY THIS FUNCTION AND THE ATTRIBUTE VALUE PAIR PLACED 
C     ON IT. THE VALUE OF THE FUNCTION IS THE OLD VALUE OF THE ATTRIBUTE 
C     IF THERE IS ONE, OTHERWISE ZERO. 
         M = MADATR(AT,LST) 
      IF (M.EQ.-1) GO TO 1
      NEWVAL = SUBST(VAL,LNKR(M)) 
      RETURN 
    1 CALL LDATVL(AT,VAL,LST) 
      NEWVAL = 0.D0 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION NOATVL(AT,LST) 
      DOUBLE PRECISION AT,L,DELETE,CONT 
      DOUBLE PRECISION JUNK 
C            NOATVL(AT,L) 
C     THIS FUNCTION REMOVES THE ATTRIBUTE AT AND ITS VALUE FROM THE 
C     DESCRIPTION LIST ASSOCIATED WITH THE LIST L. THE VALUE OF THE FUNC 
C     TION IS THE VALUE ASSOCIATED WITH THAT ATTRIBUTE. 
         M = MADATR(AT,LST) 
      IF(M.EQ.(-1)) GO TO 1
      NOATVL = DELETE(LNKR(M)) 
      JUNK=DELETE(M) 
      RETURN 
1     NOATVL = 0.D0 
      RETURN 
      END 
      FUNCTION NUCELL(X) 
      DOUBLE PRECISION DATUM
      COMMON/SLIPC1/  FAVSLC,LAVSLC 
      INTEGER FAVSLC
      DATA IDEV /16/
C            NUCELL(DUMMY) 
C     THIS FUNCTION OF NO PARAMETER CAUSES A CELL TO BE TAKEN FROM LAVS 
C     AND ITS MACHINE ADDRESS DELIVERED AS ITS VALUE. 
C     NUCELL DELIVERS THE CONTENTS OF THE LNKR FIELD OF AVSL AS ITS 
C     VALUE,I.E., ASSIGNS THE CELL PAIR THEN ON TOP OF LAVS TO ANSWER 
C     THE NEED, THEN  STORES IN THE LNKR FIELD OF AVSL THE MACHINE 
C     ADDRESS STORED  IN THE LNKR FIELD OF THE FIRST WORD OF THE DESIG- 
C     NATED WORD PAIR. 
C                                                          4/1/63 
      IF (FAVSLC.EQ.0) GO TO 9000
         NUCELL=FAVSLC
         FAVSLC=LNKR(FAVSLC)
         IF (FAVSLC.EQ.0) LAVSLC=0
C...  The cell at the top has a list name as a datum - erase the so mentioned list.
      IF (ID(NUCELL).EQ.1)  CALL IRALST(DATUM(NUCELL)) 
C...  The offered cell is zeroed out
      CALL STLNKW(0.0,NUCELL) 
      CALL STRDAT(0.0,NUCELL)
      RETURN 
9000  CONTINUE
C...  No provision for DYNACC .... fix later!!!!!!!!!!!!!!!!
      WRITE (IDEV,901) 
901   FORMAT(1H1,/6X,55HLIST OF AVAILABLE SPACE EXHAUSTED - PROGRAM TERM 
     1INATED  ) 
           CALL F4TRBK 
      END 
      FUNCTION NULSTL(LASTC,LST) 
C            NULSTL(LASTC,LST) 
C     THE INPUT PARAMETERS TO THIS FUNCTION ARE LASTC, THE NAME OF A LIST 
C     CELL ON THE LIST LST, AND THE NAME OF THE LIST LST. THE OBJECTIVE OF 
C     THIS FUNCTION IS TO SPLIT THE LIST LST BY CREATING A NEW LIST HAVING 
C     ALL CELLS TO THE LEFT (OR ABOVE) THE CELL INDICATED BY LASTC, AS WELL 
C     AS THE CELL LASTC, AS ITS MEMBERS. THE CELLS THUS ASSOCIATED WITH THE 
C     NEWLY CREATED LIST ARE REMOVED FROM THE LIST L. THE NAME OF THE 
C     NEWLY CREATED LIST IS THE VALUE OF THIS FUNCTION. 
C                                                          4/1/63 
      NULSTL = LIST(9) 
      IF (LISTMT(LST).EQ.0) RETURN
      LTOP = LNKR(LST) 
      LSUC = LNKR(LASTC) 
         CALL SETIND(-1,-1,LSUC,LST) 
         CALL SETIND(-1,LST,-1,LSUC) 
C...
         CALL SETIND(-1,LASTC,LTOP,NULSTL) 
         CALL SETIND(-1,-1,NULSTL,LASTC) 
         CALL SETIND(-1,NULSTL,-1,LTOP) 
      RETURN 
      END 
      FUNCTION NULSTR(FIRSTC,LST) 
C            NULSTR(FIRSTL,LST) 
C     THE INPUT PARAMETERS TO THIS FUNCTION ARE FIRSTC,THE NAME OF A LIST 
C     CELL ON THE LIST LST, AND THE NAME OF THE LIST LST. THE OBJECTIVE OF 
C     THIS FUNCTION IS TO SPLIT THE LIST LST BY CREATING A NEW LIST HAVING 
C     ALL CELLS TO THE RIGHT OF (OR BELOW) THE CELL FIRSTC, AS WELL AS THE 
C     CELL THE ADDRESS OF WHICH IS FIRSTC,  AS ITS MEMBERS.THE CELLS THUS 
C     ASSOCIATED WITH THE NEWLY CREATED LIST ARE REMOVED FROM THE LIST LST 
C     THE NAME OF THE NEWLY CREATED LIST IS THE VALUE OF THIS FUNCTION. 
C                                                          4/1/63 
      INTEGER FIRSTC
      NULSTR = LIST(9) 
      IF (LISTMT(LST).EQ.0) RETURN 
      LBOT = LNKL(LST) 
      LPRE = LNKL(FIRSTC) 
         CALL SETIND(-1,LPRE,-1,LST) 
         CALL SETIND(-1,-1,LST,LPRE) 
C...
         CALL SETIND(-1,LBOT,FIRSTC,NULSTR) 
         CALL SETIND(-1,NULSTR,-1,FIRSTC) 
         CALL SETIND(-1,-1,NULSTR,LBOT) 
      RETURN 
      END 
      FUNCTION NXTLFT(DAT,NSC) 
      DOUBLE PRECISION DATUM,DTEMP,DAT
C            NXTLFT(DAT,NSC) 
C     NXTLFT INSERTS THE DATUM DAT TO THE LEFT OF THE LIST CELL 
C      SPECIFIED BY NSC. THE VALUE OF THE 
C     FUNCTION IS THE NAME OF THE CELL TAKEN FROM LAVS FOR 
C     DATUM AND LINKAGE STORAGE. 
C     THIS FUNCTION CHECKS WHETHER THE DATUM BEING PLACED IS A NAME AND 
C     COUNTS THE SUBLIST COUNTER UP WHEN IT IS. 
C                                                          4/1/63 
C...  Get a cell
      NXTLFT = NUCELL(Z) 
C...  Save the LNKL of NSC
      LL = LNKL(NSC) 
C...  Set the LNKR of NSC to point to the new cell.
      CALL SETIND(-1,-1,NXTLFT,LL) 
C...  Set the LNKL of NSC to point to the new cell
      CALL SETIND(-1,NXTLFT,-1,NSC) 
C...  Set the links of the new cell
      CALL SETIND(0,LL,NSC,NXTLFT) 
C...  Does DAT contain a name?
      IF(NAMTST(DAT).NE.0) GO TO 1000 
C...     Yes it is a name; mark the cell accordingly.
         CALL SETIND(1,-1,-1,NXTLFT) 
         CALL SETMKW(6,NXTLFT)
         DTEMP=DATUM(DAT)
         CALL SETDIR(-1,-1,LCNTR(DAT)+1,DTEMP)
         CALL STRDAT(DTEMP,DAT)
1000  CONTINUE
C...  Finally! Store DAT in NXTLFT cell.
      CALL STRDAT(DAT,NXTLFT)
      RETURN 
      END 
      FUNCTION NXTRGT(DAT,NSC) 
      DOUBLE PRECISION DAT,DATUM,DTEMP
C            NXTRGT(DAT,NSC) 
C     NXTRGT INSERTS THE DATUM DAT TO THE RIGHT OF THE LIST CELL 
C      SPECIFIED BY NSC. THE VALUE OF THE 
C     FUNCTION IS THE NAME OF THE CELL TAKEN FROM LAVS FOR 
C     DATUM AND LINKAGE STORAGE. 
C     THIS FUNCTION CHECKS WHETHER THE DATUM BEING PLACED IS A NAME AND 
C     COUNTS THE SUBLIST COUNTER UP WHEN IT IS. 
C                                                          4/1/63 
      INTEGER SETDIR
      NXTRGT = NUCELL(Z) 
        LR = LNKR(NSC) 
      CALL SETIND(-1,NXTRGT,-1,LR) 
      CALL SETIND(-1,-1,NXTRGT,NSC) 
      CALL SETIND (0,NSC,LR,NXTRGT) 
         IF (NAMTST(DAT).NE.0) GO TO 1000 
      CALL SETIND(1,-1,-1,NXTRGT) 
      CALL SETMKW(6,NXTRGT)
      DTEMP=DATUM(DAT)
      CALL SETDIR(-1,-1,LCNTR(DAT)+1,DTEMP)
      CALL STRDAT(DTEMP,DAT)
1000  CONTINUE
      CALL STRDAT(DAT,NXTRGT)
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION PARMT(N,A)
      DOUBLE PRECISION A(1)
      COMMON /PUBLIC/ W(10)
      DOUBLE PRECISION W
      DATA NPUBL /10/
      IF (N.GT.NPUBL) GO TO 9000
      DO 1000 I=1,N
         CALL NEWTOP(A(I),W(I))
1000  CONTINUE
      PARMT=A(1)
9000  CONTINUE
      WRITE (IDEV,9100) N,NPUB
9100  FORMAT ('0***SLIP-ERROR***  Attempt to use ',I10,
     +'Public Lists where only ',I3,'exist. Program regretfully',
     +' terminated.')
      CALL F4TRBK
      END
      DOUBLE PRECISION FUNCTION PARMT2(A,B) 
      COMMON/PUBLIC/ W(100) 
      DOUBLE PRECISION A,B,W 
C            PARMT2(X,Y) 
C     THIS SUBROUTINE CAUSES THE INPUT PARAMETERS SPECIFIED TO BE PUSHED 
C     DOWN ON W(1) AND W(2) RESPECTIVELY. ITS UTILITY IS MAINLY IN THAT 
C     IT AIDS IN THE COMMUNICATION OF PARAMETERS FOR RECURSION. 
C                                                          4/1/63 
      CALL NEWTOP(A,W(1)) 
      CALL NEWTOP(B,W(2)) 
      PARMT2 = A 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION POPBOT(P) 
      DOUBLE PRECISION DELETE,CONT,LOCT,P 
C            POPBOT(L) 
C     THE BOTTOM CELL OF THE LIST WHOSE NAME IS THE INPUT PARAMETER TO 
C     THIS FUNCTION IS 'POPPED OFF' THAT LIST AND THE DATUM CONTAINED 
C     THEREIN DELIVERED AS THE VALUE OF THE FUNCTION. 
C                                                          4/1/63 
      POPBOT = DELETE(LNKL(LOCT(P))) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION POPTOP(P) 
      DOUBLE PRECISION DELETE,CONT,LOCT,P 
C            POPTOP(L) 
C     THE TOP CELL OF THE LIST WHOSE NAME IS THE INPUT PARAMETER TO THIS 
C     FUNCTION IS 'POPPED OFF' THAT LIST,I.E., RETURNED TO LAVS, AND THE 
C     DATUM CONTAINED THEREIN DELIVERED AS THE VALUE OF THE FUNCTION. 
C                                                          4/1/63 
      POPTOP = DELETE(LNKR(LOCT(P))) 
        RETURN 
        END 
      SUBROUTINE PRESRV(N) 
      COMMON/PUBLIC/W(100) 
      DOUBLE PRECISION TOP,W 
C            PRESRV(N) 
C     THE INPUT TO THIS FUNCTION IS AN INTEGER N (LESS THAN OR EQUAL TO 
C     100). THIS FUNCTION 'PRESERVES' THE FIRST N OF THE 100 PUBLIC 
C     LISTS W,I.E., W(1),W(2),...,W(N). TO PRESERVE A LIST , IN THE 
C     INTENDED SENSE, MEANS TO PUSH WHATEVER DATUM IS PRESENTLY ON ITS 
C     TOP ON ITS TOP ONCE MORE. THE FIRST TWO CELLS OF A PRESERVED LIST 
C     ARE THEREFORE IDENTICAL (AS SEEN BY THE PROGRAMMER). 
C                                                          4/1/63 
      DO 1 I=1,N 
    1 CALL NEWTOP(TOP(W(I)),W(I)) 
      RETURN 
      END 
      SUBROUTINE PRLSTS(OUTLST,IFORM) 
      DOUBLE PRECISION OUTLST,DATUML,ADVSWR,FORMIT(1),FORM(4)
      INTEGER UNIT,READER,RLEVEL,IDATUM(2)
      EQUIVALENCE (IDATUM,DATUML)
C     UNIT IS OUTPUT UNIT 
      DATA UNIT/16/,FORM /'(5X,I14)','(F19.8 )','(D19.8)','(5X,A8) '/
C...  Put out a title.
      WRITE (UNIT,900) 
C...
      IF (LISTMT(OUTLST).EQ.0) GO TO 9000
      READER=LRDROV(OUTLST) 
      LEVEL = 0 
1000  CONTINUE 
         DATUML=ADVSWR(READER,IFLAG) 
         RLEVEL=LCNTR(READER)
         IF (RLEVEL.GE.LEVEL) GO TO 3000
            LDIFF=LEVEL-RLEVEL
            DO 2000 I=1,LDIFF
               WRITE (UNIT,903)
2000        CONTINUE
            LEVEL=RLEVEL
            GO TO 3000
3000     CONTINUE
C....
         IF(IFLAG.NE.0) GO TO 6000 
C...        Has a listname been encountered? 
            IF (NAMTST(DATUML).EQ.0) GO TO 4000 
C...           Print according to the format specified. 
               FORMIT(1)=FORM(IFORM) 
               IF (IFORM.LT.3) WRITE (UNIT,FORMIT) IDATUM(1) 
               IF (IFORM.GT.2) WRITE (UNIT,FORMIT) DATUML 
               GO TO 5000 
4000        CONTINUE 
C...           A list name has been encountered. 
               LEVEL=LEVEL+1 
C...           Print a sub-list header. 
               WRITE (UNIT,902) 
C...           Is the sublist empty? 
               IF (LISTMT(DATUML).EQ.0) WRITE (UNIT,904) 
               GO TO 5000 
5000        CONTINUE 
            GO TO 7000 
6000     CONTINUE 
            CALL IRARDR(READER) 
         GO TO 9000 
7000     CONTINUE 
8000  CONTINUE
         GO TO 1000
9000  CONTINUE
         WRITE (UNIT,901)
      RETURN
900   FORMAT (//3X,'BEGIN LIST') 
901   FORMAT (3X,'END LIST'//) 
902   FORMAT (5X,'BEGIN  SUBLIST') 
903   FORMAT (5X,'END    SUBLIST') 
904   FORMAT (5X,' EMPTY SUBLIST') 
      END 
      SUBROUTINE RCELL(NSC) 
      INTEGER FAVSLC
      COMMON /SLIPC1/  FAVSLC,LAVSLC
C            RCELL(A) 
C     THIS SUBROUTINE RETURNS THE CELL THE ADDRESS OF WHICH IS GIVEN BY 
C     NSC TO LAVS. 
C     IN PARTICULAR, CELLS ARE ATTACHED TO THE BOTTOM OF LAVS BY MEANS 
C     OF SUITABLE MODIFICATION OF AVSL, AND OF LNKR OF THE CELL PREVIOUS 
C     LY ON THE BOTTOM OF LAVS. 
 
      IF(LAVSLC.NE.0) CALL SETIND(-1,-1,NSC,LAVSLC)
      LAVSLC=NSC
      IF (FAVSLC.EQ.0) FAVSLC=LAVSLC
C...  Set the LNKR of the released cell to zero
      CALL SETIND(-1,-1,0,NSC) 
      RETURN 
      END 
      FUNCTION RDLSTA(DUMMY)
      DOUBLE PRECISION TOP,LIST,POPTOP,REALL,RDLSTA,CHR1
      DOUBLE PRECISION BUFFER,DBLANK,MAIN,CURLST,DUMMY,STACK,DTEMP
      INTEGER LPAREN,RPAREN,BLANK,TERMNL,CRDBUF,SYMBOL,COMMA,PUTRDL
      INTEGER UNIT
      LOGICAL FPAREN
      DIMENSION CRDBUF(72)
      DATA BLANK  /'    '/
      DATA LPAREN /'(   '/
      DATA RPAREN /')   '/
      DATA COMMA  /',   '/
      DATA TERMNL /'*   '/
      DATA DBLANK /'        '/
      DATA UNIT /16/
      DATA IUNIT /15/
      DATA MAXSYM /72/
C...  Initialize BUFFER to blanks.
      BUFFER=DBLANK
      FPAREN=.FALSE.
      NBUF=0
               RDLSTA=0.0D0 
      STACK=LIST(STACK)
100   CONTINUE
      READ  (IUNIT,9997,END=9000) (CRDBUF(J),J=1,MAXSYM)
      WRITE (UNIT,9998) (CRDBUF(J),J=1,MAXSYM)
C...
C...
      DO 8000 IC=1,MAXSYM
         SYMBOL=CRDBUF(IC)
         IF (SYMBOL.EQ.LPAREN) GO TO 1000
         IF (SYMBOL.EQ.BLANK)  GO TO 3000
            IF(.NOT.FPAREN) GO TO 9500
         IF (SYMBOL.EQ.COMMA)  GO TO 4000
         IF (SYMBOL.EQ.RPAREN) GO TO 5000
         IF (SYMBOL.EQ.TERMNL) GO TO 6000
         GO TO 2000
C...
C...
1000     CONTINUE
C...     Symbol is left parenthesis.
C...        Is something in the buffer ?
            IF (BUFFER.NE.DBLANK) NBUF=PUTRDL(BUFFER,CURLST)
C...        Create the LIST or SUBLIST. 
C...        Is the MAIN LIST already established? 
            IF (FPAREN) GO TO 1110 
C...           This is the first left paren. should come here once only.
C...           Assign the list-name to RDLSTA.
               FPAREN=.TRUE. 
               CURLST=LIST(RDLSTA) 
               CALL NXTRGT(CURLST,STACK) 
               ASSIGN 7000 TO L7000 
               CALL VISIT(L7000) 
C...           Control is returned here when that right parenthesis 
C...           matching the first left one is encountered. 
               GO TO 9000 
1110     CONTINUE 
C...        Left parentheses other than first are processed here. 
C...        A SUBLIST must be created and its name 
C...        placed on the current LIST 
            DTEMP=0.0D0 
            CALL NEWBOT(LIST(DTEMP),CURLST) 
            CURLST=DTEMP 
C...        Push the current LIST name on top of the stack 
            CALL NEWTOP(DTEMP,STACK) 
            ASSIGN 6000 TO L6000 
            CALL VISIT(L6000) 
C...        Control is passed here when each inner right 
C...        parenthesis is encountered 
            CALL POPTOP(STACK) 
            CURLST=TOP(STACK) 
          IF (SYMBOL.EQ.TERMNL) CALL TERM(DUMMY)
            GO TO 7000 
C...       End of left parenthesis processing. 
C...
C...
2000     CONTINUE
C...        Regular symbol processing.
            NBUF=NBUF+1
            DTEMP=CHR1(SYMBOL)
            IF (NBUF.LE.8) CALL SHIN(8,DTEMP,BUFFER)
            GO TO 7000
C...        End of regular symbol processing.
3000     CONTINUE
C...        Here blanks are processed.
            GO TO 7000
4000     CONTINUE
C...        Comma is encountered. Just clear the buffer.
            IF ((BUFFER.NE.DBLANK).OR.
     .            (CRDBUF(IC-1).EQ.COMMA)) NBUF=PUTRDL(BUFFER,CURLST)
C...        End of comma processing
            GO TO 7000
5000     CONTINUE
C...        Begin processing right parenthesis.
            IF (BUFFER.NE.DBLANK) NBUF=PUTRDL(BUFFER,CURLST)
            CALL TERM(DUMMY)
C...        TERM passes control to last "VISITed" plus 1.
6000     CONTINUE
C...        If asterisk is encountered before parenthesis
C...        were balanced it will be necessary to unravel stacks.
            IF (SYMBOL.EQ.TERMNL) GO TO 5000
7000     CONTINUE
8000  CONTINUE
C... 
C...  Process another input line.
      GO TO 100
C...
9000  CONTINUE
        CALL IRALST(STACK)
        RETURN
C...
9500  CONTINUE
C...     Bad input format - no leading left parenthesis 
         WRITE(UNIT,9999) 
C...     Go back to read another line of input 
         GO TO 100 
9997  FORMAT(72A1)
9998  FORMAT('0',72A1)
9999  FORMAT(' ',' BAD INPUT TO RDLSTA')
      END
      FUNCTION PUTRDL(WHAT,WHERE)
      DOUBLE PRECISION DBLANK,WHAT,WHERE
      DOUBLE PRECISION LANORM,TOP
      INTEGER PUTRDL
      DATA DBLANK /'        '/
      CALL NXTLFT(LANORM(WHAT),WHERE)
      WHAT=DBLANK
      PUTRDL=0
      RETURN
      END
      DOUBLE PRECISION FUNCTION REED(K) 
      DOUBLE PRECISION DATUM 
C            REED(R) 
C     THE INPUT PARAMETER TO THIS FUNCTION IS A READER.THE VALUE OF THE 
C     FUNCTION IS THE DATUM CONTAINED IN THECELL TO WHICH THE LPNTR OF 
C     THE READER IS CURRENTLY POINTING. THE READER IS NOT MODIFIED IN 
C     ANY WAY. THIS FUNCTION MAY BE CONSIDERED A NULL ADVANCE. 
C                                                          4/1/63 
      REED = DATUM(LNKL(K)) 
      RETURN 
      END 
      FUNCTION RESTOR(N) 
      DOUBLE PRECISION W
      DATA RESTOR /10./,IDEV/16/
      COMMON /PUBLIC/ W(10) 
C            RESTOR(N) 
C     THE RESTOR SUBROUTIONE UNDOES THE WORK OF THE PRESRV SUBROUTINE, 
C     I.E., IT 'POPS UP' THE FIRST N PUBLIC LISTS. 
C                                                          4/1/63 
      IF(N.GT.10) GO TO 200
      DO 100 I=1,N 
      CALL POPTOP(W(I)) 
100   CONTINUE
      RETURN 
200   CONTINUE
      WRITE(IDEV,900) N
900   FORMAT (' This version of SLIP has only 10 Public Lists; asking to restore',
     .        I10,' Program regretfully terminated.')
      END 
      DOUBLE PRECISION FUNCTION SEQLL(S,F) 
      DOUBLE PRECISION DATUM 
      INTEGER F,S
C            SEQLL(S,F) 
C     THE LPNTR IS ADVANCED TO THE  LEFT  (UP) . F IS SET TO MINUS ONE 
C     IF THE DATUM LOCATED ON THE LIST IS AN ELEMENT (A NON-NAME), TO 
C     ZERO IF IT IS A NAME, AND TO ONE IF IT IS A HEADER. THE SEQLR 
C     OPERATION CAN THEREFORE BE INTERROGATED BY AN IF STATEMENT-- 
C            IF(F) I,J,K 
C     IF THE CELL FOUND IS A HEADER, THE VALUE OF THE FUNCTION IS ZERO. 
C     OTHERWISE, THE VALUE IS THE DATUM CONTAINED IN THE CELL. 
      L=LNKL(S) 
      S=L
      SEQLL=DATUM(L) 
      IF (ID(L)-1) 10,20,30 
10    F = -1 
       RETURN 
20    F = 0 
      RETURN 
30    F = 1 
      SEQLL=0.0D0
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION SEQLR(S,F) 
      DOUBLE PRECISION DATUM 
      INTEGER F,S
C            SEQLR(S,F) 
C     THE LPNTR IS ADVANCED TO THE RIGHT (DOWN). F IS SET TO MINUS ONE 
C     IF THE DATUM LOCATED ON THE LIST IS AN ELEMENT (A NON-NAME), TO 
C     ZERO IF IT IS A NAME, AND TO ONE IF IT IS A HEADER. THE SEQLR 
C     OPERATION CAN THEREFORE BE INTERROGATED BY AN IF STATEMENT-- 
C            IF(F) I,J,K 
C     IF THE CELL FOUND IS A HEADER, THE VALUE OF THE FUNCTION IS ZERO. 
C     OTHERWISE, THE VALUE IS THE DATUM CONTAINED IN THE CELL. 
      L=LNKR(S) 
      S=L
      SEQLR = DATUM(L) 
      IF (ID(L)-1) 10,20,30 
10    F = -1 
       RETURN 
20    F = 0 
      RETURN 
30    F = 1 
      SEQLR=0.0D0
      RETURN 
      END 
      FUNCTION SEQRDR(LST) 
      INTEGER SEQRDR
      DOUBLE PRECISION LST,LOCT,CONT 
C            SEQRDR(LST) 
C     THE STATEMENT S=SEQRDR(LST) CAUSES S TO BE A SEQUENCE READER OF 
C     THE LIST LST. THAT IS, SEQRDR IS A FUNCTION THE VALUE OF WHICH IS 
C     A SINGLE COMPUTER WORD IN THE SEQUENCE READER FORMAT. IT MAY 
C     TRAVERSE A LIST OR LIST STRUCTURE IN MUCH THE SAME WAY AS A READER 
C     BUT IT DOES NOT STORE HISTORICAL INFORMATION WITH RESPECT TO ITS 
C     DESCENTS INTO LIST STRUCTURES AND IS THEREFORE NOT ABLE TO 
C     ASCEND FROM A SUBLIST INTO A MAIN LIST. THE SEQUENCE READER IS NOT 
C     TAKEN FROM LAVS AND NEED NOT BE ERASED. 
      SEQRDR=LNKLW(LOCT(LST)) 
      RETURN 
      END 
      FUNCTION SEQSL(S,F) 
      DOUBLE PRECISION DATUM,SEQSL
      INTEGER F,S
C            SEQSL(S,F) 
C     THE LPNTR OF THE SEQUENCE READER IS ADVANCED TO THE  LEFT  (UP). 
C      THE ENCOUNTER OF A HEADER ON ANY LEVEL CAUSES THE FLAG F TO BE 
C     SET TO ONE, BUT NO ASCENSION WITHIN THE LIST STRUCTURE. THE 
C     ENCOUNTER OF A LIST NAME CAUSES A DESCENT INTO THE LIST STRUCTURE 
C     HOWEVER. THE FLAG F IS SET TO A MINUS ONE IF THE CELL ENCOUNTERED 
C     IS AN ELEMENT (A NON-NAME).THE VALUE OF THE FUNCTION IS ZERO IF 
C     THE CELL ENCOUNTERED IS A HEADER, AND IS THE DATUM IN THE CELL IF 
C     IT IS AN ELEMENT. 
         IF (ID(S).NE.1) GO TO 1000
         S=LNKLW(DATUM(S))
         GO TO 2000
1000  CONTINUE
         S=LNKL(S)
2000  CONTINUE
         IF (ID(S).NE.1) GO TO 3000
         S=LINKLW(DATUM(S))
3000  CONTINUE
         SEQSL=DATUM(S)
         F=ID(S)-1
         IF (F.EQ.1) SEQSL=0.0D0
      RETURN 
      END 
      FUNCTION SEQSR(S,F) 
      DOUBLE PRECISION DATUM,SEQSR
      INTEGER F,S
C            SEQSR(S,F) 
C     THE LPNTR OF THE SEQUENCE READER S ISADVANCED TO THE RIGHT (DOWN). 
C      THE ENCOUNTER OF A HEADER ON ANY LEVEL CAUSES THE FLAG F TO BE 
C     SET TO ONE, BUT NO ASCENSION WITHIN THE LIST STRUCTURE. THE 
C     ENCOUNTER OF A LIST NAME CAUSES A DESCENT INTO THE LIST STRUCTURE 
C     HOWEVER. THE FLAG F IS SET TO A MINUS ONE IF THE CELL ENCOUNTERED 
C     IS AN ELEMENT (A NON-NAME).THE VALUE OF THE FUNCTION IS ZERO IF 
C     THE CELL ENCOUNTERED IS A HEADER, AND IS THE DATUM IN THE CELL IF 
C     IT IS AN ELEMENT. 
         IF (ID(S).NE.1) GO TO 1000
         S=LNKRW(DATUM(S))
         GO TO 2000
1000  CONTINUE
         S=LNKR(S)
2000  CONTINUE
         IF (ID(S).NE.1) GO TO 3000
         S=LNKRW(DATUM(S))
3000  CONTINUE
         SEQSR=DATUM(S)
         F=ID(S)-1
         IF (F.EQ.1) SEQSR=0.0D0
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION SUBSBT(DAT,LST) 
      DOUBLE PRECISION SUBST,DAT,CONT 
C            SUBSBT(P,M) 
C     THE DATUM P REPLACES THE DATUM PRESENTLY STORED ON THE BOTTOM OF 
C     THE LIST M. THE VALUE OF THIS FUNCTION IS THE DATUM REPLACED BY IT 
C     I.E., THE PREVIOUS CONTENTS OF THE BOTTOM OF THE LIST. 
C                                                          4/1/63 
         SUBSBT = SUBST(DAT,LNKL(LST)) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION SUBST(DAT,CADR) 
      DOUBLE PRECISION DAT,CONT,DELETE,DATEMP,DATUM,DTEMP
      INTEGER CADR
C            SUBST(DAT,CADR) 
C     THE DATUM P REPLACES THAT STORED IN THE LIST CELL WHOSE ADDRESS IS 
C     SPECIFIED BY CADR. THE REPLACED DATUM IS THE VALUE OF THIS FUNCTION. 
C                                                          4/1/63 
C...  This version of SUBST (by B. Herzog, January 1974) differs from
C...  Weizenbaum's. It avoids the problems that occur when a READER is left
C...  pointing to the cell whose datum is being changed. Weizenbaum's
C...  specification is still satisfied - the warning is released.
C...
C...
      DATEMP=DATUM(CADR)
C...  Now determine if DATEMP refers to a list - if so erase it
      IF(NAMTST(DATEMP).EQ.0) CALL IRALST(DATEMP)
C...  Now determine if DAT refers to a list - if so increase counter
      IF(NAMTST(DAT).NE.0) GO TO 100
C...  It is a list name - get its header's datum
      DTEMP=DATUM(DAT)
C...  Now increase its LCNTR
      CALL SETDIR(-1,-1,LNKR(DTEMP)+1,DTEMP)
C...  Now put it back
      CALL STRDAT(DTEMP,DAT)
100   CONTINUE
C...  Put the new datum in CADR
      CALL STRDAT(DAT,CADR)
      SUBST=DATEMP
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION SUBSTP(P,M) 
      DOUBLE PRECISION SUBST,P,CONT 
C            SUBSTP(P,M) 
C     THE DATUM P REPLACES THE DATUM PRESENTLY ON TOP OF THE LIST M. THE 
C     VALUE OF THIS FUNCTION IS THE DATUM REPLACED BY IT,I.E., THE 
C     PREVIOUS CONTENTS OF THE TOP OF THE LIST M. 
C                                                          4/1/63 
         SUBSTP = SUBST(P,LNKR(M)) 
      RETURN 
      END 
      DOUBLE PRECISION FUNCTION TOP(L) 
      DOUBLE PRECISION L,LOCT,CONT,DATUM 
C                                                          4/1/63 
C            TOP(L) 
C     THE INPUT PARAMETER TO THE FUNCTION TOP IS THE NAME OF A LIST. ITS 
C     VALUE IS THE DATUM STORED ON THE TOP (LEFTMOST) CELL ON THAT LIST. 
C     THE LIST IS NOT MODIFIED BY THIS OPERATION. 
      TOP = DATUM(LNKR(LOCT(L))) 
      RETURN 
      END 
      FUNCTION MRKGET(CADR)
C...   THIS FUNCTION ADDED BY B. HERZOG, JANUARY 1974
      DOUBLE PRECISION CONT
      MRKGET=MRK(CADR)
      RETURN
      END
      SUBROUTINE SLPERR(ERRNO,ARG)
      INTEGER EUNIT
      DOUBLE PRECISION ARG
      INTEGER ERRNO
      DATA EUNIT /16/
      DATA MAXERR /8/
      IF (ERRNO.GT.MAXERR) GO TO 8000
      GO TO (100,200,300,400,500,600,700,800),ERRNO
100   CONTINUE
C...  From DELETE
      WRITE (EUNIT,10) ERRNO,ARG
      GO TO 9000
200   CONTINUE
C...  From DERROR
      WRITE (EUNIT,20) ERRNO,ARG
      GO TO 9100
300   CONTINUE
C...  From IRALST
      WRITE (EUNIT,30) ERRNO,ARG
      GO TO 9000
400   CONTINUE
C...  From IRALST
      WRITE (EUNIT,40) ERRNO,ARG
      GO TO 9000
500   CONTINUE
C...  From LISTAV
      WRITE (EUNIT,50) ERRNO,ARG
      GO TO 9000
600   CONTINUE
C...  From LOCT
      WRITE (EUNIT,50) ERRNO,ARG
      GO TO 9100
700   CONTINUE
C...  From NUCELL
      WRITE (EUNIT,70) ERRNO
      GO TO 9100
800   CONTINUE
      WRITE (EUNIT,80) ERRNO
      GO TO 9100
10    FORMAT(1H1,'***',I3,'*** An attempt has been made to delete a'/
     .' header (hexvalue=',Z8,'); zero has been supplied and the '/
     .'program has been continued.')
20    FORMAT(1H1,'***',I3,' *** Attribute list (hexvalue=',Z8,') offered '/
     .'but not found.')
30    FORMAT(1H1,'***',I3,' *** Attempt to delelte an ill-named or '/
     .'ill-formed list (hexvalue=',Z8,'); zero has been returned.')
40    FORMAT (1H1,'***',I3,' ***Attempt to delete a list (Hexvalue=',Z8,/
     .') whose use count is zero or less; zero returned.')
50    FORMAT(1H1,'***',I3,' ***Argument given (Hexvalue=',Z8,') is not a'/
     .'name.')
70    FORMAT(1H1,'***',I3,' ***List of available space exhausted.')
80    FORMAT(1H1,'***',I3,' *** GETSPA failed when called in SETBLK.')
8000  CONTINUE
         WRITE (EUNIT,8001) ERRNO
8001     FORMAT(1H1,'***',I3,'******** is an illegal error number.')
9000    CONTINUE
         RETURN
9100  CONTINUE
         WRITE (EUNIT,9101)
9101     FORMAT(' Program regretfully terminated.')
         CALL F4TRBK
      END
