      FUNCTION ADVLEL(R,F) 
      INTEGER ADVLL,F,R
C            ADVLEL(R,F) 
C     THE LPNTR OF THE READER R MOVES  LEFT  (UP)  TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO AN ELEMENT
C     (AN ELEMENT IS A NON-NAME). IF THAT ELEMENT IS NOT A HEADER,F IS 
C     SET TO ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED 
C     THAT ELEMENT. IF THE ELEMENT IS A HEADER, F IS SET TO NONZERO AND 
C     THE VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLL(R,0,0) 
      IF (F.NE.0) GO TO 1 
      ADVLEL = REED(R) 
      RETURN
    1 CONTINUE
      ADVLEL=0.0
      RETURN
      END 
      FUNCTION ADVLER(R,F) 
      INTEGER F,ADVLR,R
C            ADVLER(R,F) 
C     THE LPNTR OF THE READER R MOVES RIGHT (DOWN) TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO AN ELEMENT 
C     (AN ELEMENT IS A NON-NAME). IF THAT ELEMENT IS NOT A HEADER,F IS 
C     SET TO ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED 
C     THAT ELEMENT. IF THE ELEMENT IS A HEADER, F IS SET TO NONZERO AND 
C     THE VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLR(R,0,0) 
      IF (F.NE.0) GO TO 1 
      ADVLER = REED(R) 
      RETURN 
  1   CONTINUE
      ADVLER=0.0
      RETURN
      END 
      FUNCTION ADVLL(LR,J,K) 
      INTEGER ADVLL,R,F,SETIND
C                                                          4/1/63 
1     CONTINUE
         LK=LNKL(LNKL(LR))
         IDUM=SETIND(-1,LK,-1,LR)
         ITEMP=ID(LK)
      IF(ITEMP .EQ. 2) GO TO 3
      IF(ITEMP .EQ. J) GO TO 2
      IF(ITEMP .NE. K) GO TO 1
2     ADVLL = 0 
      GO TO 4 
3     ADVLL = -1 
4     CONTINUE
      RETURN 
      END 
      FUNCTION ADVLNL(R,F) 
      INTEGER ADVLL,F,R
C            ADVLNL(R,F) 
C     THE LPNTR OF THE READER R MOVES  LEFT  (UP)  TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO A NAME. IF 
C     THAT  STOP WAS ACTUALLY MADE AT A NAME AND NOT A HEADER, F IS SET 
C     TO ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED IN 
C     THE NAME.. IF THE STOP WAS MADE AT A HEADER, F IS SET TO NONZERO 
C     AND THE VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLL(R,1,1) 
      IF (F.NE.0) GO TO 1 
      ADVLNL = REED(R) 
      RETURN
    1 CONTINUE
      ADVLNL=0.0
      RETURN
      END 
      FUNCTION ADVLNR(R,F) 
      INTEGER ADVLR,F,R
C            ADVLNR(R,F) 
C     THE LPNTR OF THE READER R MOVES RIGHT (DOWN) TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO A NAME. IF 
C     THAT  STOP WAS ACTUALLY MADE AT A NAME AND NOT A HEADER, F IS SET 
C     TO ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED IN 
C     THE NAME.. IF THE STOP WAS MADE AT A HEADER, F IS SET TO NONZERO 
C     AND THE VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLR(R,1,1) 
      IF (F.NE.0) GO TO 1 
      ADVLNR = REED(R) 
      RETURN
    1 CONTINUE
      ADVLNR=0.0
      RETURN
      END 
      FUNCTION ADVLR(LR,J,K) 
      INTEGER ADVLR,SETIND
1     CONTINUE
         LK=LNKR(LNKL(LR))
      IDUM=SETIND(-1,LK,-1,LR) 
      ITEMP=ID(LK)
      IF(ITEMP .EQ. 2) GO TO 3 
      IF(ITEMP .EQ. J) GO TO 2 
      IF(ITEMP .NE. K) GO TO 1 
    2 CONTINUE
      ADVLR = 0 
      GO TO 4 
    3 ADVLR = -1 
4     CONTINUE
      RETURN 
      END 
      FUNCTION ADVLWL(R,F) 
      INTEGER ADVLL,R,F
C            ADVLWL(R,F) 
C     THE LPNTR OF THE READER R MOVES LEFT  (UP)   TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO A WORD (A 
C     WORD IS A NAME OR NONNAME).IF THAT WORD IS NOT A HEADER, F IS SET 
C     TO  ZERO AND THE VALUE FO THE FUNCTION IS THE DATUM CONTAINED IN 
C     THAT WORD. IF THE WORD IS A HEADER, F IS SET TO NONZERO AND THE 
C     VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLL(R,1,0) 
      IF (F.NE.0) GO TO 1 
      ADVLWL = REED(R) 
      RETURN
    1 CONTINUE
      ADVLWL=0.0
      RETURN
      END 
      FUNCTION ADVLWR(R,F) 
      INTEGER ADVLR,R,F
C            ADVLWR(R,F) 
C     THE LPNTR OF THE READER R MOVES RIGHT (DOWN) TO ONE AFTER ANOTHER 
C     OF THE LIST CELLS OF WHICH THE READER IS A READER, GUIDED BY THE 
C     LINKING INFORMATION IN THE LIST, UNTIL IT POINTS TO TO A WORD (A 
C     WORD IS A NAME OR NONNAME).IF THAT WORD IS NOT A HEADER, F IS SET 
C     TO  ZERO AND THE VALUE OF THE FUNCTION IS THE DATUM CONTAINED IN 
C     THAT WORD. IF THE WORD IS A HEADER, F IS SET TO NONZERO AND THE 
C     VALUE OF THE FUNCTION IS ZERO. 
      F = ADVLR(R,1,0) 
      IF (F.NE.0) GO TO 1 
      ADVLWR = REED(R) 
      RETURN
    1 CONTINUE
      ADVLWR=0.0
      RETURN
      END 
      FUNCTION ADVSEL(R,F) 
      INTEGER ADVSL,R,F
C            ADVSEL(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL LEFT 
C     (UP)    IS CHECKED TO SEE IF IT IS AN ELEMENT (AN ELEMENT IS A 
C     NON-NAME). IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST. THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY. THE NEXT CELL  LEFT  (UP)  IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENT 
C     ED BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F=ADVSL(R,0,0) 
      IF (F.NE.0) GO TO 1 
      ADVSEL = REED(R) 
      RETURN
    1 CONTINUE
      ADVSEL=0.0
      RETURN
      END 
      FUNCTION ADVSER(R,F) 
      INTEGER ADVSR,R,F
C            ADVSER(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL RIGHT 
C     (DOWN)  IS CHECKED TO SEE IF IT IS AN ELEMENT (AN ELEMENT IS A 
C     NON-NAME). IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST. THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY. THE NEXT CELL RIGHT (DOWN) IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENT 
C     ED BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F = ADVSR(R,0,0) 
      IF (F.NE.0) GO TO 1 
      ADVSER = REED(R) 
      RETURN
    1 CONTINUE
      ADVSER=0.0
      RETURN
      END 
      FUNCTION ADVSL(LR,J,K)
C...  Recoded by B. Herzog, January 1974.
C...  The coding of J and K
C...  If J=0 and K=0 seeking element - non name
C...     J=1 and K=0 seeking word
C...     J=1 and K=1 seeking name
      INTEGER ADVSL,SETIND
      ADVSL=0.
C...  Get the cell pointer
      LPTR=LNKL(LR)
C...  Does the initial cell's datum contain a list name?
      IF(ID(LPTR).EQ.1) GO TO 300
C...  No it does not
100   CONTINUE
C...  Proceed to the next left cell; update the list pointer
      LPTR=LNKL(LPTR)
C...  Update the reader
      IDUM=SETIND(-1,LPTR,-1,LR)
C...  What is the nature of the datum? Test the ID which may be 0, 1 or 2.
      ITEMP=ID(LPTR)
C...  Is the KANDidate cell a header?
      IF(ITEMP.EQ.2) GO TO 200
C...  No it was not a header. Thus ITEMP can only be 0 or 1
C...  Thus if J and K are different word is sought
      IF(J.NE.K) RETURN
C...  So J.EQ.K and if ITEMP.EQ.J more success
      IF(ITEMP.EQ.J) RETURN
      IF(ITEMP.EQ.0) GO TO 100
      GO TO 300
C...
200   CONTINUE
C...  A header has been encountered
C...  Is the reader on the main list? Check its level counter.
C...  If no go, to pop the stack
      IF(LCNTR(LR).NE.0) GO TO 400
C...  It is at the head of the main list. Set flag.
      ADVSL=-1
C...  Take exit
      RETURN
C...
300   CONTINUE
      CALL PSHRDR(LR,LPTR)
      GO TO 100
C...
400   CONTINUE
C...  Ready to pop the reader stack
C...
      CALL POPRDR(LR,LPTR)
      GO TO 100
      END
      SUBROUTINE PSHRDR(LR,LPTR)
      INTEGER SETDIR,STLNKW,SETIND
C...  The cell does contain the name of a list and a reader is to be appointed to it
C...  The previous reader must be pushed; get a cell.
      M=NUCELL(Z)
C...  Get the datum and linkword of LR; put them into the new cell.
      IDUM=STLNKW(LINKWD(LR),M)
      RDUM=STRDAT(IDATUM(LR),M)
C...  Now update the active reader
C...  Set the LNKR to point to the new cell
      IDUM=SETIND(-1,-1,M,LR)
C...  Store the sub-list name's cell address, found in LPTR's datum
C...  in the LNKL.  Count up the level counter and put it back into DTEMP2.
      ITEMP=IDATUM(LR)
      IDUM=SETDIR(-1,IDATUM(LPTR),LCNTR(LR)+1,ITEMP)
C...  Update the reader's datum
      RDUM=STRDAT(ITEMP,LR)
C...  Update LPTR
      LPTR=IDATUM(LPTR)
      RETURN
      END
      SUBROUTINE POPRDR(LR,LPTR)
      INTEGER STLNKW
      NEXRDR=LNKR(LR)
C...  Take the linkword and datum of the NEXRDR and place in LR
      IDUM=STLNKW(LINKWD(NEXRDR),LR)
      RDUM=STRDAT(IDATUM(NEXRDR),LR)
C...  Release the cell NEXRDR
      CALL RCELL(NEXRDR)
      LPTR=LNKL(LR)
      RETURN
      END
      FUNCTION ADVSNL(R,F) 
      INTEGER ADVSL,R,F
C            ADVSNL(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL LEFT 
C     (UP)    IS CHECKED TO SEE IF IT IS A NAME. 
C                IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST.THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY.THE NEXT CELL  LEFT  (UP)  IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENT 
C     ED BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F = ADVSL(R,1,1) 
      IF (F.NE.0) GO TO 1 
      ADVSNL = REED(R) 
      RETURN
    1 CONTINUE
      ADVSNL=0.0
      RETURN
      END 
      FUNCTION ADVSNR(R,F) 
      INTEGER ADVSR,R,F
C            ADVSNR(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL RIGHT 
C     (DOWN)  IS CHECKED TO SEE IF IT IS A NAME. 
C                IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST. THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY. THE NEXT CELL RIGHT (DOWN) IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENT 
C     ED BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
      F = ADVSR(R,1,1) 
      IF (F.NE.0) GO TO 1 
      ADVSNR = REED(R) 
      RETURN
    1 CONTINUE
      ADVSNR=0.0
      RETURN
      END 
      FUNCTION ADVSR(LR,J,K)
C...  Recoded by B. Herzog, January 1974.
C...  The coding of J and K
C...  If J=0 and K=0 seeking element - non name
C...     J=1 and K=0 seeking word
C...     J=1 and K=1 seeking name
      INTEGER ADVSR,SETIND
      ADVSR=0.
C...  Get the cell pointer
      LPTR=LNKL(LR)
C...  Does the initial cell's datum contain a list name?
      IF(ID(LPTR).EQ.1) GO TO 300
C...  No it does not
100   CONTINUE
C...  Proceed to the next left cell; update the list pointer
      LPTR=LNKR(LPTR)
C...  Update the reader
      IDUM=SETIND(-1,LPTR,-1,LR)
C...  What is the nature of the datum? Test the ID which may be 0, 1 or 2.
      ITEMP=ID(LPTR)
C...  Is the KANDidate cell a header?
      IF(ITEMP.EQ.2) GO TO 200
C...  No it was not a header. Thus ITEMP can only be 0 or 1
C...  Thus if J and K are different word is sought
      IF(J.NE.K) RETURN
C...  So J.EQ.K and if ITEMP.EQ.J more success
      IF(ITEMP.EQ.J) RETURN
      IF(ITEMP.EQ.0) GO TO 100
      GO TO 300
C...
200   CONTINUE
C...  A header has been encountered
C...  Is the reader on the main list? Check its level counter.
C...  If no go, to pop the stack
      IF(LCNTR(LR).NE.0) GO TO 400
C...  It is at the head of the main list. Set flag.
      ADVSR=-1
C...  Take exit
      RETURN
C...
300   CONTINUE
      CALL PSHRDR(LR,LPTR)
      GO TO 100
C...
400   CONTINUE
C...  Ready to pop the reader stack
C...
      CALL POPRDR(LR,LPTR)
      GO TO 100
      END
      FUNCTION ADVSWL(R,F) 
      INTEGER ADVSL,R,F
C            ADVSWL(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL LEFT 
C     (UP)    IS CHECKED TO SEE IF IT IS A WORD (A WORD IS A NAME OR A 
C     NON-NAME). IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST. THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY. THE NEXT CELL  LEFT  (UP)  IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENTED 
C     BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F = ADVSL(R,1,0) 
      IF (F.NE.0) GO TO 1 
      ADVSWL = REED(R) 
      RETURN
    1 CONTINUE
      ADVSWL=0.0
      RETURN
      END 
      FUNCTION ADVSWR(R,F) 
      INTEGER ADVSR,R,F
C            ADVSWR(R,F) 
C     THE ID OF THE CELL CURRENTLY BEING POINTED TO BY THE LPNTR OF THE 
C     READER R IS CHECKED TO SEE IF IT IS A NAME. IF IT IS, THE READER 
C     BECOMES A READER OF THE LIST THE NAME OF WHICH IS STORED IN THAT 
C     CELL. THE LCNTR OF THE READER IS COUNTED UP BY ONE. THE FIELD OF 
C     THE READER WHICH HOLDS THE NAME OF THE LIST BEING READ (RETRIEVABL 
C     BY LOFRDR) IS SUITABLY MODIFIED.IF THE CELL CURRENTLY BEING 
C     POINTED TO BY THE LPNTR IS NOT A NAME, THEN THE NEXT CELL RIGHT 
C     (DOWN)  IS CHECKED TO SEE IF IT IS A WORD (A WORD IS A NAME OR A 
C     NON-NAME). IF IT IS, THE VALUE OF THE FUNCTION IS THE DATUM 
C     CONTAINED IN THAT CELL AND F IS SET TO ZERO. IF IT IS NOT, AND  IT 
C     IS NOT A HEADER, THE WHOLE PROCESS IS REPEATED. IF THE CELL IS A 
C     HEADER, THE LCNTR OF THE READER DETERMINES WHETHER THE ADVANCE 
C     CONTINUES. IF THE LCNTR IS ZERO, THE READER IS READING THE MAIN 
C     LIST AND THE END OF THE ENTIRE LIST STRUCTURE HAS BEEN ENCOUNTERED 
C     IN THAT CASE, THE VALUE OF THE FUNCTION IS ZERO AND F IS NONZERO. 
C     IF THE LCNTR IS NONZERO, THE HEADER WHICH WAS ENCOUNTERED MERELY 
C     INDICATES THE END OF A SUBLIST.THE READER THEREFORE ASCENDS FROM 
C     THAT SUBLIST TO THAT LIST CELL ON THE HIGHER ORDER LIST WHICH LED 
C     INTO THE SUBLIST INITIALLY.THE NEXT CELL RIGHT (DOWN) IS THEN 
C     EXAMINED AND THE WHOLE PROCESS IS REPEATED. THE LCNTR IS DECREMENTED 
C     BY ONE IN THE ASCENSION AND THE NAME OF THE LIST TO WHICH THE 
C     READER HAS ASCENDED IS RECORDED IN THE APPROPRIATE READER FIELD. 
C
      F = ADVSR(R,1,0) 
      IF (F.NE.0) GO TO 1 
      ADVSWR = REED(R) 
      RETURN
    1 CONTINUE
      ADVSWR=0.0
      RETURN
      END 
      FUNCTION BOT(/L/) 
C            BOT(L) 
C     THE INPUT PARAMETER TO THE FUNCTION BOT IS THE NAME OF A LIST. ITS 
C     VALUE IS THE DATUM STORED ON THE BOTTOM (RIGHTMOST) CELL ON THAT 
C     LIST. THE LIST IS NOT MODIFIED BY THIS OPERATION. 
C                                                          4/1/63 
      BOT = DATUM(LNKL(LOCT(L))) 
      RETURN 
      END 
      FUNCTION DELETE(/NSC/) 
C            DELETE(NSC) 
C     THE INPUT PARAMETER TO THIS FUNCTION IS THE ADDRESS OF A 
C     LIST CELL. THE LIST CELL SO INDICATED IS DELETED FROM THE LIST ON 
C     WHICH IT APPEARS AND THE DATUM STORED IN THAT CELL DELIVERED AS 
C     THE VALUE OF THE FUNCTION. IF THE ADDRESS OF A LIST HEADER IS 
C     GIVEN AS THE INPUT PARAMETER, THEN THE VALUE OF THE FUNCTION WILL 
C     BE ZERO AND AN ERROR MESSAGE PRINTED. THE PROGRAM WILL CONTINUE TO 
C     BE EXECUTED. 
C                                                          4/1/63 
      INTEGER ERRDEV,SETIND
      DATA ERRDEV /16/
      IF (ID(NSC).EQ.2) GO TO 9000 
         DELETE = DATUM(NSC) 
         LL = LNKL(NSC) 
         LR = LNKR(NSC) 
         IDUM=SETIND(-1,-1,LR,LL) 
         IDUM=SETIND(-1,LL,-1,LR) 
         CALL RCELL(NSC) 
      RETURN 
9000  CONTINUE
         WRITE (ERRDEV,9010) 
         DELETE = 0.0 
      RETURN 
9010  FORMAT(1H1,/99H AN ATTEMPT HAS BEEN MADE TO DELETE A HEADER - ZERO 
     1 HAS BEEN DELIVERED AND THE PROGRAM CONTINUED.             ) 
      END 
      SUBROUTINE DERROR(/LST/) 
      INTEGER ERRDEV /16/
         WRITE (ERRDEV,9000) LST 
      RETURN 
9000  FORMAT (1H2,'***SLIP-ERROR***  ATTTRIBUTE-VALUE LIST SOUGHT FOR',
     .A8,' BUT NOT FOUND.')
      END 
      FUNCTION INITRD(NRD) 
C            INITRD(NRD) 
C     THIS FUNCTION CAUSES THE LPNTR OF THE READER WHICH IS ITS INPUT 
C     PARAMETER TO POINT TO THE HEADER OF THE LIST THE READER IS 
C     CURRENTLY POINTING INTO. THE VALUE OF THE FUNCTION IS THE ADDRESS 
C     OF THE READER. TO COMPLETELY INITIALIZE A READER, THE STATEMENT-- 
C            CALL INITRD(LVLRVT(NRD)) 
C     WOULD BE USED. 
C                                                          4/1/63 
      INTEGER SETIND
      IDUM=SETIND(-1,LNKLW(DATUM(NRD)),-1,NRD) 
      INITRD =NRD 
      RETURN 
      END 
      FUNCTION INLSTL(/LST/,NSC) 
C            INLSTL(LST,NSC) 
C     LST MUST BE THE ALIAS OF A LIST AND NSC THE MACHINE ADDRESS OF A LIST 
C     CELL. INLSTL TAKES THE SET OF LINKED CELLS CONSTITUTING THE BODY 
C     OF THE LIST LST,I.E., ALL BUT THE HEADER OF THAT LIST, AND INSERTS 
C     IT TO THE LEFT OF THE CELL NSC. LST IS MADE INTO AN EMPTY LIST AND ITS 
C     NAME DELIVERED AS THE VALUE OF THE FUNCTION. 
C                                                          4/1/63 
      INTEGER SETIND
         LST = LOCT(LST) 
         ITOP = LNKR(LST) 
         IBOT = LNKL(LST) 
      INLSTL=LST 
C...  Fix up the header of the body less list
      IDUM=SETIND(-1,LST,LST,LST) 
C...  Get the LNKL of cell NSC
         IPRE = LNKL(NSC) 
C...  Reset the lnkl of cell NSC
      IDUM=SETIND(-1,IBOT,-1,NSC) 
C...  Reset the LNKR of the cell that previously preceded NSC
      IDUM=SETIND(-1,-1,ITOP,IPRE) 
C...  Reset the LNKL of the top cell inserted
      IDUM=SETIND(-1,IPRE,-1,ITOP) 
C...  Reset the LNKR of the bottom cell inserted
      IDUM=SETIND(-1,-1,NSC,IBOT) 
      RETURN 
      END 
      FUNCTION INLSTR(/LST/,NSC) 
C            INLSTR(LST,NSC) 
C     LST MUST BE THE ALIAS OF A LIST AND NSC THE MACHINE ADDRESS OF A LIST 
C     CELL. INLSTR TAKES THE SET OF LINKED CELLS CONSTITUTING THE BODY 
C     OF THE LIST LST,I.E., ALL BUT THE HEADER OF THAT LIST, AND INSERTS 
C     IT TO THE RIGHT OF THE CELL NSC. LST IS MADE INTO AN EMPTY LIST AND 
C     ITS NAME DELIVERED AS THE VALUE OF THIS FUNCTION. 
C                                                          4/1/63 
      INTEGER SETIND
         LST=LOCT(LST) 
         ITOP = LNKR(LST) 
         IBOT = LNKL(LST) 
      INLSTR=LST 
      IDUM=SETIND(-1,LST,LST,LST) 
         ISUC = LNKR(NSC) 
      IDUM=SETIND(-1,-1,ITOP,NSC) 
      IDUM=SETIND(-1,IBOT,-1,ISUC) 
      IDUM=SETIND(-1,NSC,-1,ITOP) 
      IDUM=SETIND(-1,-1,ISUC,IBOT) 
      RETURN 
      END 
      FUNCTION IRALST(/LST/) 
      INTEGER SETDIR,SETMKW,SETIND
      INTEGER ERRDEV/16/
C            IRALST(LST) 
C     THE LIST THE NAME OF WHICH APPEARS AS AN INPUT PARAMETER TO THIS 
C     FUNCTION IS ERASED,I.E., ALL ITS CELLS, INCLUDING ITS HEADER, ARE 
C     RESTORED TO LAVS BY THIS FUNCTION. HOWEVER, THIS LIST (AND ITS 
C     CONTENTS) MAY STILL BE THE SUBLIST OF ANOTHER LIST. THE ERASURE IS 
C     NOT ACTUALLY CARRIED OUT IF THAT CONDITION IS DETECTED. (THE 
C     REFERENCE COUNTER OF THE LIST IS MERELY COUNTED DOWN BY ONE IN 
C     THAT EVENT.) THE VALUE OF THE FUNCTION IS AN INTEGER SPECIFYING 
C     OF HOW MANY LISTS THE SUBJECT LIST IS A SUBLIST. IF THAT VALUE IS 
C     ZERO, THE LIST HAS ACTUALLY BEEN ERASED. 
C                                                          4/1/63 
C...  Extensive changes. B. Herzog, January 1974.
C...  Is the offered LST really a list name?
      IF(NAMTST(LST).NE.0) GO TO 300
C...  It is a proper list name; therefore get its reference counter.
      IRALST=LCNTR(LST)
C...  If that reference counter value is less than or equal to zero already then
C...  something is wrong.
      IF(IRALST.LT.0) GO TO 400
C...  If it is greater than zero: count it down.
      IF (IRALST.GT.0) IRALST=IRALST-1
C...  If the reference counter is now equal to zero, branch to removal sequence.
      IF(IRALST.EQ.0) GO TO 100
C...
C...  Rference counter is still one or greater.
      DATUML=DATUM(LST)
C...  Update the reference counter and return
      IDUM=SETDIR(-1,-1,IRALST,DATUML)
      RDUM=STRDAT(DATUML,LST)
      RETURN
100   CONTINUE
C...  The reference counter is zero; so we may return list to LAVS.
C...  First empty the list; i.e., return its cells to LAVS
      IDUM=MTLIST(LST)
C...  Look at the header. Does it refer to a description list?
      N=LNKLW(DATUM(LST))
      IF(N.EQ.0) GO TO 200
C...  There is a reference to a description list.
C...  Fix up the header cell about to be returned to look like
C...  a cell with a name of a list.
C...  First the ID field is set to 1 for NUCELL
      IDUM=SETIND(1,0,0,LST)
C...  Now fix the datum to be in list name format for NAMTST
      DATUML=DATUM(LST)
      IDUM=SETDIR(1,N,N,DATUML)
      IDUM=SETMKW(6,DATUML)
      RDUM=STRDAT(DATUML,LST)
C...  Now its all ready to return
200   CONTINUE
      CALL RCELL(LNKRW(LST))
      RETURN
300   CONTINUE
C...  A list name was expected but was not offered
      WRITE(ERRDEV,910)
      IRALST=0
      RETURN
400   CONTINUE
C...  The reference counter of the offered list is already zero or less
      IRALST=0
      WRITE (ERRDEV,910)
      WRITE(ERRDEV,920)
      RETURN
910   FORMAT('0 ATTEMP TO DELETE AN ILL NAMED OR ILL FORMED LIST.',
     .' 0 RETURNED.')
920   FORMAT('0 ATTEMPT TO DELETE A LIST WHOSE USE COUNT IS ZERO'
     .,' OR LESS. 0 RETURNED.')
      END 
      FUNCTION IRARDR(R) 
      INTEGER R,SETIND
C            IRARDR(R) 
C     THIS FUNCTION ERASES (RESTORES TO LAVS) THE READER WHICH IS ITS 
C     INPUT PARAMETER. THE VALUE OF THE FUNCTION IS THE LCNTR OF THE 
C     READER,I.E., AN INTEGER WHICH INDICATES HOW DEEPLY WITHIN A LIST 
C     STRUCTURE THE ERASED READER WAS POINTING PRIOR TO ITS ERASURE. 
C                                                          4/1/63 
      IRARDR = LCNTR(R) 
         M = R 
    3    N = LNKR(M) 
      IF(ID(M).NE.3) RETURN 
      IDUM=SETIND (0,-1,-1,M) 
         CALL RCELL(M) 
         IF(N.EQ.0) RETURN 
         M = N 
         GOTO 3 
      END 
      FUNCTION ITSVAL(/AT/,LST) 
C            ITSVAL(AT,L) 
C     THIS FUNCTION PRODUCES THE VALUE OF THE ATTRIBUTE AT AS STORED ON 
C     THE DESCRIPTION LIST OF THE LIST L AS ITS VALUE. IF THE ATTRIBUTE 
C     CANNOT BE FOUND, THE VALUE OF THE FUNCTION IS ZERO. 
         IF(LNKLW(DATUM(LST)).EQ.0) GO TO 10 
    3    M = MADATR(AT,LST) 
      IF((M).EQ.(-1)) GO TO 20 
      ITSVAL =   IDATUM(LNKR(M)) 
      RETURN 
   10 CALL DERROR(LST) 
20    ITSVAL = 0 
      RETURN 
      END 
      FUNCTION LCNTR(R) 
      INTEGER R
C            LCNTR(R) 
C     THE INPUT PARAMETER R TO THIS FUNCTION IS THE ADDRESS OF A READER 
C     THE VALUE OF THE FUNCTION IS THE LCNTR (LEVEL COUNTER) OF THE 
C     READER, DELIVERED IN THE FORM OF AN INTEGER. 
C                                                          4/1/63 
      LCNTR = LNKRW(DATUM(R)) 
      RETURN 
      END 
      FUNCTION LDATVL(/AT/,/VL/,/LST/) 
         IF(LNKLW(DATUM(LST)).EQ.0) LDATVL=LISTAV(LST) 
      IDUM=NXTRGT(VL,NXTLFT(AT,LNKLW(DATUM(LST) ))) 
      RETURN 
      END 
      FUNCTION LIST(/K/) 
      INTEGER SETDIR,SETIND,SETMRK
C            LIST(K) 
C     THIS FUNCTION CREATES AN EMPTY LIST AND LEAVES ITS NAME BOTH AS 
C     ITS VALUE AND IN THE CELL K, UNLESS K IS THE INTEGER 9 IN WHICH 
C     CASE THE NAME IS JUST THE VALUE OF THE FUNCTION. THE CELL K 
C     THUS BECOMES AN ALIAS FOR THE LIST UNLESS IT WAS A 9. TWO ALIASES 
C     MAY BE ESTABLISHED AT ONCE BY WRITING, FOR EXAMPLE, 
C            LA= LIST(LB) 
C     WHICH CAUSES BOTH LA AND LB TO CONTAIN THE NAME OF THE CREATED 
C     LIST. UNLESS K IS THE LITERAL 9, THE REFERENCE COUNTER (NUMBER OF 
C     LISTS FOR WHICH THIS LIST IS A SUBLIST) WILL BE SET TO ONE INITIAL 
C     LY. THUS IT WILL NEVER BE INADVERTANTLY ERASED. IF K IS A 9,  THE 
C     REFERENCE COUNTER IS SET TO ZERO. 
C                                                          4/1/63 
C...  Obtain a cell
      NSC=NUCELL(Z) 
C... Fix up the link word as a header
      IDUM=SETIND(2,NSC,NSC,NSC) 
      IDUM=SETMRK(6,NSC) 
C...  Fix up a SLIP name
      LIST=LINKWD(NSC)
      IDUM=SETDIR(1,-1,-1,LIST)
C...  Now fix the DATUM  of the header.
      IF (K.EQ.9) GO TO 1000
      DTEMP = DATUM(NSC)
      IDUM=SETDIR(-1,-1,1,DTEMP)
      RDUM=STRDAT(DTEMP,NSC)
      K = LIST 
1000  CONTINUE
      RETURN 
      END 
      FUNCTION LISTAV(/LST/) 
      INTEGER SETDIR
      INTEGER ERRDEV /16/
      LISTAV=LIST(9) 
      IF(NAMTST(LST).NE.0) WRITE(ERRDEV,901)
C     DTEMP = DATUM(LST)
C     IDUM=SETDIR(-1,LNKR(LISTAV),-1,DTEMP)
C     RDUM=STRDAT(DTEMP,LST)
      RDUM=STRDAT(SETDIR(-1,LNKR(LISTAV),-1,DATUM(LST)),LST)
      RETURN 
 901  FORMAT('  ERROR IN LISTAV: THE ARGUMENT GIVEN IS NOT A LIST ****')
      END 
      FUNCTION LISTMT(/LSTNAM/) 
C            LISTMT(LSTNAM) 
C     THE INPUT PARAMETER TO THIS FUNCTION IS THE NAME OF A LIST. IF 
C     THAT LIST IS EMPTY, THE VALUE OF THE FUNCTION IS ZERO, OTHERWISE 
C     THE FUNCTION HAS A NONZERO VALUE. 
C                                                          4/1/63 
      LISTMT = 0 
      L = LOCT(LSTNAM) 
      IF (LINKWD(L).NE.LINKWD(LNKR(L))) LISTMT=-1
       RETURN 
      END 
      FUNCTION LOCT(K) 
      INTEGER ERRDEV /16/
C                                                          4/1/63 
      IF(NAMTST(K).NE.0) GO TO 1000 
      LOCT = K 
      RETURN 
C
1000  CONTINUE
      WRITE (ERRDEV,9000) 
9000  FORMAT(1H1,/'  A LIST WAS REQUIRED AS AN OPERAND BUT WAS NOT' 
     .,' FOUND  THE PROGRAM WAS REGRETFULLY TERMINATED.') 
      CALL F4TRBK 
         RETURN
      END 
      FUNCTION LOFRDR(K) 
      INTEGER SETDIR,SETMKW
C            LOFRDR(R) 
C     THE INPUT PARAMETER R TO THIS FUNCTION IS THE ADDRESS OF A READER. 
C     THE VALUE OF THE FUNCTION IS THE NAME OF THE LIST WHICH THE READER 
C     R IS CURRENTLY READING.THIS VALUE IS DELIVERED IN NAME FORMAT. 
C                                                          4/1/63 
      L = LNKLW(DATUM(K)) 
      IDUM=SETDIR(1,L,L,LL) 
      IDUM=SETMKW(6,LL) 
      LOFRDR=LL 
      RETURN 
      END 
      FUNCTION LPNTR(LRD) 
C            LPNTR(R) 
C     THE INPUT PARAMETER TO THE LPNTR FUNCTION IS THE ADDRESS OF A 
C     READER. THE VALUE OF THE FUNCTION IS 
C     THE LPNTR FIELD OF THAT READER,I.E., THE ADDRESS OF THE CELL TO 
C     WHICH THAT READER IS CURRENTLY POINTING. 
C                                                          4/1/63 
      LPNTR = LNKL(LRD) 
      RETURN 
      END 
      FUNCTION LPURGE(/LST/) 
C                                                          4/1/63 
      K = LRDROV(LST) 
         LPURGE = 0 
    3 X = ADVSWR(K,J) 
    6    IF(J)2,1,2 
    1 IF (NAMTST(X))3,4,3 
    4 IF (LSTPRO(X,K))3,5,3 
    5    L = LPNTR(K) 
      X = ADVLWR(K,J) 
      RDUM=DELETE(L) 
         LPURGE = LPURGE+1 
      GOTO 6 
    2 IDUM=IRARDR(K) 
      RETURN 
      END 
      FUNCTION LRDRCP(K) 
C            LRDRCP(R) 
C     THE OBJECTIVE OF THIS FUNCTION IS TO MAKE A COPY OF THE READER 
C     WHICH IS ITS INPUT PARAMETER AND TO DELIVER THE ADDRESS OF THAT 
C     COPY AS ITS VALUE.THE COPY PRODUCED BY THIS FUNCTION MAY BE 
C     ADVANCED AS IF IT WERE THE ORIGINAL READER. 
C                                                          4/1/63 
      INTEGER STLNKW,SETIND
         LRDRCP = NUCELL(Z) 
         NEWR = LRDRCP 
         NOW = K 
  1   CONTINUE
      IDUM=STLNKW(LINKWD(NOW),NEWR)
      RDUM=STRDAT(DATUM(NOW),NEWR) 
         NOW = LNKR(NOW) 
           IF (NOW.EQ.0) GO TO 2 
        NEW = NUCELL(Z) 
      IDUM=SETIND(-1,-1,NEW,NEWR) 
         NEWR = NEW 
         GO TO 1 
    2 RETURN 
      END 
      FUNCTION LRDROV(/LST/) 
      INTEGER SETDIR,SETIND
C            LRDROV(LST)
C     THIS FUNCTION APPOINTS A READER FOR THE LIST WHOSE ALIAS IS GIVEN 
C     AS ITS INPUT PARAMETER. THE VALUE OF THE FUNCTION IS THE ADDRESS 
C     OF THE CELL TAKEN FROM LAVS,I.E., THE CELL WHICH WAS ACTUALLY PUT 
C     IN THE FORMAT OF A READER. IN ITS INITIAL STATE, THE READER IS 
C     POINTING AT THE HEADER OF THE LIST FOR WHICH IT WAS CREATED. 
C                                                          4/1/63 
      LRDROV = NUCELL(Z) 
      IDUM=SETIND(3,LOCT(LST),0,LRDROV) 
      DTEMP=0.
      IDUM=SETDIR(0,LST,0,DTEMP)
      RDUM=STRDAT(DTEMP,LRDROV)
      RETURN 
      END 
      INTEGER FUNCTION LSSCPY(/LSTORG/)
      INTEGER READER,DATTYP
      COMMON /PUBLIC/ LSTPUB(10)
      EQUIVALENCE (L100,NL100)
C...  The input parameter to this function is a list name.   The 
C...  objective of this function is to create a list, the name of which
C...  is the value of the function, such that the newly created list
C...  is a copy of the input list or list structure.
      DATTYP=0
      ASSIGN 100 TO L100
      READER=LRDROV(LSTORG)
      NEWLST=0
      NEWLST=LIST(NEWLST)
      IDUM=INTGER(PARMT2(READER,NEWLST))
      LSSCPY=IVISIT(NL100)
      RETURN
C...  Two stacks are maintained;  the top of the first, LSTPUB(1), holds
C...  name of the reader appointed to the list or sublist being copied.
C...  The top of the second stack, LSTPUB(2), holds the name of the list,
C...  or sublist, currently being created and filled.
C...
C...  Begin Loop.
100   CONTINUE
         READER=INTGER(TOP(LSTPUB(1)))
         NEWLST=INTGER(TOP(LSTPUB(2)))
200      CONTINUE
C...        Advance the reader.
            DATM=ADVLWR(READER,IFLAG)
            DATTYP=NAMTST(DATM)
C...        Has the reader advanced to the HEADER?
            IF(IFLAG.EQ.0) GO TO 300
C...           A HEADER has been encountered
               IDUM=IRARDR(READER)
C...           Pop the stacks via TERM
               RDUM=RESTOR(2)
               RDUM=TERM(NEWLST)
C...           That's the end of the recursive loop. TERM returns 
C...           control to the most recent "VISITed" plus 1.
               GO TO 400
300         CONTINUE 
C              If DATM is a list name a sub-list 
C              must be created.
               IF (DATTYP.EQ.0) DATM=REALS(LIST(9)) 
               IDUM=NEWBOT(DATM,NEWLST) 
C              Now push the stacks via VISIT if a sub-list.
      IF (DATTYP.EQ.0) IDUM=INTGER(PARMT2(LRDROV(REED(READER)),DATM))
               IF (DATTYP.EQ.0) RDUM=VISIT(NL100)
               GO TO 400 
400         CONTINUE
500      CONTINUE
         IF ((IFLAG.EQ.0).AND.(DATTYP.NE.0)) GO TO 200 
600   CONTINUE 
      IF ((IFLAG.EQ.-1).OR.(DATTYP.EQ.0)) GO TO 100 
         RETURN
      END
      FUNCTION LSTEQL(/LISTA/,/LISTB/) 
      INTEGER READLA,READLB
      COMMON /PUBLIC/  LSTPUB(10) 
      EQUIVALENCE (L100,NL100)
C 
C...  Recoded by B. Herzog, September 1975.
C 
C      The two input parameters to this function are both 
C      names of list structures. The objective of this 
C      function is to determine whether or not these 
C      list structures are equal. If they are, the value 
C      of the function is zero, otherwise it is nonzero. 
C      The two list structures are equal if they have 
C      identical structures, i.e., sublist names 
C      appearing in corresponding places within both 
C      structures, and if corresponding elements 
C      appearing in both structures are identical. 
C 
      LSTEQL=0
      ASSIGN 100 TO L100
      RDUM=PARMT2(LRDROV(LISTA),LRDROV(LISTB))
      LSTEQL=IVISIT(NL100)
      RETURN 
100   CONTINUE
         READLA=INTGER(TOP(LSTPUB(1))) 
         READLB=INTGER(TOP(LSTPUB(2))) 
C...
200   CONTINUE 
      IF (LSTEQL.NE.0) GO TO 800
C...     Advance the readers on both lists.
         DATUMA=ADVLWR(READLA,IFLAGA) 
         DATUMB=ADVLWR(READLB,IFLAGB) 
C...     Inquire if the structures are the same.
C...     IFLAGA or IFLAGB will be non-zero if a HEADER 
C...     is encountered on the corresponding list.
         IF (IFLAGA.NE.IFLAGB) GO TO 600
C...        So the structures are the same. Do the readers 
C...        returned to the HEADER?
            IF (IFLAGA.NE.0) GO TO 500
C...           No. Now examine the DATUM returned from each list. 
C...           Are they list names?
C...           NAMTST yields zero if Datum is name of a list.
               IF ((NAMTST(DATUMA).EQ.0)
     .                    .AND.(NAMTST(DATUMB).EQ.0)) GO TO 300
C...              Not list names! But does DATUMA.EQ.DATUMB?
                  IF (DATUMA.NE.DATUMB) LSTEQL=-1
                  GO TO 400
300           CONTINUE
C...           So both are list names; keep advancing.
                  RDUM=PARMT2(LRDROV(DATUMA),LRDROV(DATUMB))
                  LSTEQL=IVISIT(NL100)
                  IF (LSTEQL.EQ.0) GO TO 100
                  GO TO 400
400         CONTINUE
500       CONTINUE
             GO TO 700
600       CONTINUE
C...      Arrive here if the list structures are not equal.
             LSTEQL=-1
700    CONTINUE
800    CONTINUE
      IF ((LSTEQL.EQ.0).AND.(IFLAGA.EQ.0)) GO TO 900
C....
         IDUM=IRARDR(TOP(LSTPUB(1))) 
         IDUM=IRARDR(TOP(LSTPUB(2))) 
         CALL TERM(REALS(LSTEQL),RESTOR(2)) 
900      CONTINUE
      GO TO 200
      END 
      FUNCTION LSTMRK(/LST/) 
C            LSTMRK(L) 
C     THE INPUT PARAMETER TO THIS FUNCTION IS THE NAME OF THE LIST L. 
C     ITS VALUE IS THE MARK ON THAT LIST. 
         LSTMRK = IDW(DATUM(LOCT(LST))) 
      RETURN 
      END 
      FUNCTION LSTPRO(/L/,NEXT) 
C                                                          4/1/63 
1     IF(LNKLW(DATUM(NEXT)).EQ.LNKRW(L)) GO TO 2 
      NEXT = LNKR(NEXT) 
      IF(NEXT.EQ.0) GO TO 1
      LSTPRO=-1
      RETURN 
2     LSTPRO = 0 
      RETURN 
      END 
      FUNCTION LVLRV1(K) 
      INTEGER STLNKW
C          LVLRV1(R) 
C     THE OBJECTIVE OF THIS FUNCTION IS TO CAUSE THE READER R TO ASCEND 
C     (REVERSE) ONE LEVEL IN THE LIST STRUCTURE INTO WHICH IT IS 
C     IS LEFT POINTING TO THAT CELL IN THE NEXT HIGHER LIST WHICH 
C     CONTAINS THE NAME OF THE SUBSTRUCTURE INTO WHICH THE READER WAS 
C     CURRENTLY POINTING. IF THE READER IS ALREADY POINTING TO WITHIN 
C     THE MAIN LIST, NOTHING HAPPENS. OTHERWISE, THE LPNTR OF THE READER 
C     POINTING WHEN THE OPERATION WAS INITIATED. THE VALUE OF THE 
C     FUNCTION IS THE ADDRESS OF THE READER. 
C                                                          4/1/63 
         LVLRV1 = K 
      IF ((LNKRW(DATUM(K)).EQ.0).OR.(LNKR(K).EQ.0)) RETURN 
      L = LNKR(K) 
      IDUM=STLNKW(LINKWD(L),K) 
      RDUM=STRDAT(DATUM(L),K)
      CALL    RCELL(L) 
      RETURN 
      END 
      FUNCTION LVLRVT(R) 
         INTEGER R,STLNKW
C            LVLRVT(R) 
C     THE OBJECTIVE OF THIS FUNCTION IS TO CAUSE THE READER WHICH IS ITS 
C     INPUT PARAMETER TO ASCEND (REVERSE) IN THE LIST STRUCTURE INTO 
C     WHICH IT IS CURRENTLY POINTING UNTIL IT IS AGAIN POINTING INTO THE 
C     (MAIN) LIST FOR WHICH IT WAS ORIGINALLY APPOINTED. IF THE READER 
C     IS ALREADY POINTING TO WITHIN THE MAIN LIST, NOTHING HAPPENS. 
C     OTHERWISE, THE LPNTR OF THE READER IS LEFT POINTING TO THAT CELL 
C     IN THE MAIN LIST WHICH CONTAINS THE NAME OF THE SUBSTRUCTURE INTO 
C     WHICH THE READER WAS POINTING WHEN THIS OPERATION WAS INITIATED. 
C     THE VALUE OF THE FUNCTION IS THE ADDRESS OF THE READER. THUS, THIS 
C     FUNCTION MAY SERVE AS THE INPUT PARAMETER TO ANY OTHER FUNCTION RE 
C     QUIRING A READER AS ONE OF ITS PARAMETERS. 
C                                                          4/1/63 
         LVLRVT = R 
1000  CONTINUE
      IF ((LNKRW(DATUM(K)).EQ.0).OR.(LNKR(K).EQ.0)) RETURN 
      L=LNKR(R) 
      IDUM=STLNKW(LINKWD(L),R) 
      RDUM=STRDAT(DATUM(L),R)
      CALL    RCELL(L) 
      GO TO 1000
      END 
      FUNCTION MADATR(/AT/,/LST/) 
      LSTDES = LNKLW(DATUM(LST)) 
      IF(LSTDES.EQ.0) GO TO 20
      MADATR = LNKR(LSTDES) 
   10 IF(ID(MADATR).EQ.2) GO TO 20
      IF(DATUM(MADATR).EQ.AT) RETURN
      M = LNKR(MADATR) 
         IF (ID(M).EQ.2) GO TO 20 
      MADATR = LNKR(M) 
         GO TO 10 
20    MADATR = -1 
      RETURN 
      END 
      FUNCTION MADLFT(/CADR/) 
      INTEGER CADLFT,FLAG,CADR,SETDIR,SETMKW
C            MADLFT(CADR) 
C     THE INPUT PARAMETER CADR TO THIS FUNCTION IS THE ADDRESS OF A 
C     LIST CELL OR A HEADER. THE VALUE OF THE FUNCTION IS THE AD 
C     DRESS OF THE CELL TO THE LEFT OF (ABOVE) THAT BEING SPECIFIED BY 
C     CADR. IF THAT MACHINE ADDRESS SHOULD TURN OUT TO BE A HEADER, THEN 
C     THE VALUE WILL BE DELIVERED IN THE FORMAT OF A LIST NAME, 
C     OTHERWISE AS AN INTEGER 
C                                                          4/1/63 
C...
C...  Reprogrammed to use CADLFT by B. HERZOG, September, 1975.
      FLAG=0
      MADLFT=CADLFT(CADR,FLAG)
C...  Is it a HEADER?
      IF (FLAG.NE.-1) RETURN
C...  The cell is a HEADER.
C...
      IDUM=SETDIR(1,CADLFT,CADLFT,MADLFT) 
      IDUM=SETMKW(6,MADLFT) 
      RETURN 
      END 
      INTEGER FUNCTION CADLFT(/CADR/,FLAG)
      INTEGER CADR,FLAG
      FLAG=0
      CADLFT= LNKL(CADR) 
C...  Is the cell a HEADER/?
      IF(ID(CADLFT).EQ.2) FLAG=-1
      RETURN
      END 
      FUNCTION MADNBT(/LSTNAM/,N) 
      INTEGER CADNBT,FLAG,SETDIR,SETMKW
C            MADNBT(L,N) 
C     THE INPUT PARAMETERS TO THIS FUNCTION ARETHE NAME OF A LIST LSTNAM, AND 
C     AN INTEGER N. THE OBJECTIVE OF THIS FUNCTION IS TO DELIVER THE 
C     ADDRESS OF THE NTH LIST CELL FROM THE BOTTOM OF THE LIST 
C     LSTNAM. IF THAT CELL IS THE HEADER OF THE LIST LSTNAM, THEN THE VALUE IS 
C     DELIVERED IN THE FORMAT OF THE LIST NAME LSTNAM, OTHERWISE THE VALUE IS 
C     AN INTEGER. IF N IS GREATER THAN THE NUMBER OF CELLS ON THE LIST LSTNAM
C     (INCLUDING THE HEADER CELL), THEN THE EFFECT OF THIS  FUNCTION IS 
C     AS IF N MODULO M HAD BEEN THE SECOND INPUT PARAMETER, WHERE M IS 
C     THE ACTUAL NUMBER OF CELLS (INCLUDING THE HEADER) ON THE LIST L. 
C                                                          4/1/63 
C
C..   Reprogrammed to use CADNBT by B. Herzog, September 1975.
      MADNBT=CADNBT(LSTNAM,N,FLAG)
      IF (FLAG.EQ.0) RETURN
      MADNBT=SETDIR(1,MADNBT,MADNBT,ITEMP) 
      IDUM=SETMKW(6,MADNBT) 
      RETURN 
      END 
      INTEGER FUNCTION CADNBT(/LSTNAM/,N,FLAG)
      INTEGER CADR,FLAG
      FLAG=0
      CADR=LNKRW(LOCT(LSTNAM))
      DO 100 I=1,N
         CADR=LNKR(CADR)
100   CONTINUE
      CADNBT=CADR
      IF(ID(CADR).EQ.2) FLAG=-1
      RETURN
      END
      FUNCTION MADNTP(/LSTNAM/,N) 
      INTEGER CADNTP,FLAG,SETDIR,SETMKW
C            MADNTP(L,N) 
C     THE INPUT PARAMETERS TO THIS FUNCTION ARETHE NAME OF A LIST LSTNAM, AND 
C     AN INTEGER N. THE OBJECTIVE OF THIS FUNCTION IS TO DELIVER THE 
C     ADDRESS OF THE NTH LIST CELL FROM THE TOP OF THE LIST 
C     LSTNAM. IF THAT CELL IS THE HEADER OF THE LIST LSTNAM, THEN THE VALUE IS 
C     DELIVERED IN THE FORMAT OF THE LIST NAME LSTNAM, OTHERWISE THE VALUE IS 
C     AN INTEGER. IF N IS GREATER THAN THE NUMBER OF CELLS ON THE LIST LSTNAM
C     (INCLUDING THE HEADER CELL), THEN THE EFFECT OF THIS  FUNCTION IS 
C     AS IF N MODULO M HAD BEEN THE SECOND INPUT PARAMETER, WHERE M IS 
C     THE ACTUAL NUMBER OF CELLS (INCLUDING THE HEADER) ON THE LIST L. 
C                                                          4/1/63 
C
C..   Reprogrammed to use CADNTP by B. Herzog, September 1975.
      MADNTP=CADNTP(LSTNAM,N,FLAG)
      IF (FLAG.EQ.0) RETURN
      MADNTP=SETDIR(1,MADNTP,MADNTP,ITEMP) 
      IDUM=SETMKW(6,MADNTP) 
      RETURN 
      END 
      INTEGER FUNCTION CADNTP(/LSTNAM/,N,FLAG)
      INTEGER CADR,FLAG
      FLAG=0
      CADR=LNKLW(LOCT(LSTNAM))
      DO 100 I=1,N
         CADR=LNKL(CADR)
100   CONTINUE
      CADNTP=CADR
      IF(ID(CADR).EQ.2) FLAG=-1
      RETURN
      END
      FUNCTION MADRGT(/CADR/) 
      INTEGER CADRGT,FLAG,CADR,SETDIR,SETMKW
C            MADRGT(CADR) 
C     THE INPUT PARAMETER CADR TO THIS FUNCTION IS THE ADDRESS OF A 
C     LIST CELL OR A HEADER. THE VALUE OF THE FUNCTION IS THE AD 
C     DRESS OF THE CELL TO THE RIGHT OF (BELOW) THAT BEING SPECIFIED BY 
C     CADR. IF THAT MACHINE ADDRESS SHOULD TURN OUT TO BE A HEADER, THEN 
C     THE VALUE WILL BE DELIVERED IN THE FORMAT OF A LIST NAME, 
C     OTHERWISE AS AN INTEGER 
C                                                          4/1/63 
C...
C...  Reprogrammed to use CADRGT by B. HERZOG, September, 1975.
      FLAG=0
      MADRGT=CADRGT(CADR,FLAG)
C...  Is it a HEADER?
      IF (FLAG.NE.-1) RETURN
C...  The cell is a HEADER.
C...
      IDUM=SETDIR(1,CADRGT,CADRGT,MADRGT) 
      IDUM=SETMKW(6,MADRGT) 
      RETURN 
      END 
      INTEGER FUNCTION CADRGT(/CADR/,FLAG)
      INTEGER CADR,FLAG
      FLAG=0
      CADRGT= LNKR(CADR) 
C...  Is the cell a HEADER/?
      IF(ID(CADRGT).EQ.2) FLAG=-1
      RETURN
      END 
      FUNCTION MAKEDL(/L/,/M/) 
C            MAKEDL(L,M) 
C     THIS FUNCTION MAKES THE LIST L A DESCRIPTION LIST OF THE LIST M. 
C     THE VALUE OF THE FUNCTION IS THE NAME OF THE LIST M. 
C...  First we attempt to remove any description
C...  lists of the asserted list M.
      INTEGER SETDIR
      IDUM=MTDLST(M) 
      N= LOCT(M) 
      K= LOCT(L) 
C     DTEMP=DATUM(N)
C     IDUM=SETDIR(-1,K,-1,DTEMP)
C     RDUM=STRDAT(DTEMP,N)
      RDUM=STRDAT(SETDIR(-1,K,-1,DATUM(N)),N)
C     DTEMP=DATUM(K)
C     IDUM=SETDIR(-1,-1,LCNTR(L)+1,DTEMP)
C     RDUM=STRDAT(DTEMP,K)
      RDUM=STRDAT(SETDIR(-1,-1,LCNTR(L)+1,DATUM(K)),K)
      MAKEDL = M 
      RETURN 
      END 
      FUNCTION MRKLSS(/M/,/LST/) 
C            MRKLSS(M,L) 
C     THE OBJECTIVE OF MRKLSS IS TO PLACE THE MARK 0,1,2, OR 3 ON EVERY 
C     LIST OF THE LIST STRUCTURE L. IN THE SENSE OF THIS FUNCTION, ALL 
C     LISTS ARE MARKED WITH 0 INITIALLY. THE VALUE OF THE FUNCTION IS 
C     THE NAME OF THE LIST L, I.E., THE SECOND INPUT PARAMETER. 
      INTEGER SETDIR
      MRKLSS = LST 
      LR = LRDROV(MRKLST(M,LST)) 
1000  CONTINUE
         X = ADVSNR(LR,K) 
         IF(K.NE.0) GO TO 2000 
C     DTEMP=DATUM(LNKRW(X))
C     IDUM=SETDIR(M,-1,-1,DTEMP)
C     RDUM=STRDAT(DTEMP,LNKRW(X))
      RDUM=STRDAT(SETDIR(M,-1,-1,DATUM(X)),X)
      GO TO 1000 
2000  CONTINUE
      IDUM=IRARDR(LR) 
      RETURN 
      END 
      FUNCTION MRKLST(/M/,/LST/) 
      INTEGER SETDIR,ERRDEV
      DATA ERRDEV /16/
C            MRKLST(M,L) 
C     THE OBJECTIVE OF MRKLST IS TO PLACE THE MARK 0,1,2,OR 3 ON THE 
C     LIST L. IN THE SENSE OF THIS FUNCTION ALL LISTS ARE MARKED WITH 
C     ZERO INITIALLY. THE VALUE OF THIS FUNCTION IS THE NAME OF THE LIST 
C     L,I.E., THE SECOND INPUT PARAMETER. 
      IF ((M.LT.0).OR.(M.GT.3)) GO TO 1000
      MRKLST = LST 
      ITEMP=LNKRW(LOCT(LST))
      DTEMP=DATUM(ITEMP)
      IDUM=SETDIR(M,-1,-1,DTEMP)
      RDUM=STRDAT(DTEMP,ITEMP)
      GO TO 99999
1000  CONTINUE
         WRITE (ERRDEV,00001) M
         CALL F4TRBK
         GO TO 99999
99999 CONTINUE
      RETURN 
00001  FORMAT (1H1,'****SLIP Error ***, MRKLST was offered'/
     .             ' an invalid mark of value =',I10)
      END 
      FUNCTION MTDLST(/LST/) 
      INTEGER SETDIR,SETMKW
C            MTDLST(L) 
C     THIS FUNCTION EMPTIES THE DESCRIPTION LIST OF THE LIST L. ITS 
C     VALUE IS THE NAME OF THE LIST L. 
         MTDLST = LST 
      K=LNKLW(DATUM(LOCT(LST))) 
         IF(K.EQ.0) RETURN 
C...  Now fix up a word to look like a list name for MTLIST
      IDUM=SETDIR(1,K,K,X) 
      IDUM=SETMKW(6,X) 
      IDUM=MTLIST(X) 
      RETURN 
      END 
      FUNCTION MTLIST(/P/) 
      INTEGER FAVSLC,SETIND,P
      COMMON/SLIPC1/  FAVSLC,LAVSLC 
C            MTLIST(L) 
C     THE LIST THE NAME OF WHICH APPEARS AS AN INPUT PARAMETER TO THIS 
C     FUNCTION IS EMPTIED, I.E., ITS CELLS RESTORED TO LAVS. THE VALUE 
C     OF THE FUNCTION IS THE NAME OF THE EMPTY LIST L. 
C     WHEN A LIST IS TO BE RESTORED TO LAVS, THE CELL PRESENTLY ON THE 
C     BOTTOM OF LAVS IS MADE TO POINT TO THE TOP OF THE LIST BEING 
C     ERASED, THE BOTTOM CELL OF THAT LIST IS GIVEN THE APPEARANCE OF A 
C     BOTTOM CELL OF LAVS, AND THE BOTTOM POINTER OF AVSL,I.E., ITS LNKL 
C     FIELD, IS SET TO POINT TO THAT BOTTOM CELL. 
C                                                          4/1/63 
         M = LOCT(P) 
         IF (LISTMT(P).EQ.0) GO TO 1000 
C...  Get the LNKL and LNKR of the header
         NSCTOP = LNKR(M) 
         NSCBOT = LNKL(M) 
C...  Set the header for an empty list header
         IDUM=SETIND(-1,M,M,M) 
C...  Now link the released cells on LAVS
         IDUM=SETIND(-1,-1,NSCTOP,LAVSLC)
         LAVSLC=NSCBOT
         IDUM=SETIND(-1,-1,0,LAVSLC)
1000  CONTINUE
         MTLIST = M 
      RETURN 
      END 
      FUNCTION NAMEDL(/L/) 
      INTEGER SETDIR,SETMKW
C            NAMEDL(L) 
C     THE VALUE OF THIS FUNCTION IS THE NAME OF THE DESCRIPTION LIST OF 
C     THE LIST L WHICH IS ITS INPUT PARAMETER. 
C...  Get the address of the description list
      LL=LNKLW(DATUM(LOCT(L))) 
C...  Fix up NAMEDL so that its content is in list name format
      IDUM=SETDIR(1,LL,LL,NAMEDL) 
      IDUM=SETMKW(6,NAMEDL) 
      RETURN 
      END 
      FUNCTION NAMTST(/NAME/) 
C            NAMTST(NAME) 
C     THE DATUM NAME IS EXAMINED. IF IT IS THE NAME OF A LIST, THE VALUE OF 
C     THE FUNCTION IS ZERO, OTHERWISE THE VALUE OF THE FUNCTION IS 
C     NONZERO. 
C                                                          4/1/63 
      IF (LNKLW(NAME).NE.LNKRW(NAME)) GO TO 1000 
      IF(IDW(NAME).NE.1) GO TO 1000
      IF (MRKW(NAME) .NE. 6) GO TO 1000 
      IF (ID(NAME).NE.2) GO TO 1000 
      LINK=LNKR(NAME)
C      CHECK TO SEE IF THIS CELL IS AT THE END OF THE AVSL; THEN LINK=0.
       IF(LINK.EQ.0) GO TO 1000
      IF(LNKR(LNKL(NAME)).NE.LNKL(LNKR(NAME))) GO TO 1000
      NAMTST = 0 
        RETURN 
1000  CONTINUE
      NAMTST = -1 
        RETURN 
      END 
      FUNCTION NEWBOT(/P/,/Q/) 
      INTEGER Q
C            NEWBOT(P,Q) 
C     NEWBOT PUSHES THE DATUM P UP ON THE BOTTOM OF THE LIST Q. ITS VALU 
C     IS THE NUMBER OF THE CELL TAKEN FROM LAVS FOR THE STORAGE 
C     OF THE DATUM AND THE ASSOCIATED LINKING INFORMATION. 
C                                                          4/1/63 
         NEWBOT = NXTLFT(P,LOCT(Q)) 
      RETURN 
      END 
      FUNCTION NEWTOP(/P/,/Q/) 
      INTEGER Q
C            NEWTOP(P,Q) 
C     NEWTOP PUSHES THE DATUM P DOWN ON TOP OF THE LIST Q. ITS VALUE IS 
C     THE NUMBER OF THE CELL TAKEN FROM LAVS FOR THE STORAGE OF 
C     THE DATUM AND THE ASSOCIATED LINKING INFORMATION. 
C                                                          4/1/63 
         NEWTOP = NXTRGT(P,LOCT(Q)) 
      RETURN 
      END 
      REAL FUNCTION NEWVAL(/AT/,/VAL/,/LST/) 
C            NEWVAL(AT,VAL,L) 
C     THE OBJECTIVE OF THIS FUNCTION IS TO ASSIGN THE VALUE VAL TO THE 
C     ATTRIBUTE AT ON THE DESCRIPTION LIST OF THE LIST L. VAL REPLACES 
C     WHATEVER THE PREVIOUS VALUE OF AT MAY HAVE BEEN. IF THE ATTRIBUTE 
C     AT CANNOT BE FOUND, IT IS ADDED (TOGETHER WITH ITS VALUE) TO THE 
C     DESCRIPTION LIST. IF NO DESCRIPTION LIST FOR THE LIST L EXISTS, 
C     ONE IS CREATED BY THIS FUNCTION AND THE ATTRIBUTE VALUE PAIR PLACED 
C     ON IT. THE VALUE OF THE FUNCTION IS THE OLD VALUE OF THE ATTRIBUTE 
C     IF THERE IS ONE, OTHERWISE ZERO. 
         M = MADATR(AT,LST) 
      IF (M.EQ.-1) GO TO 1
      NEWVAL = SUBST(VAL,LNKR(M)) 
      RETURN 
    1 IDUM=LDATVL(AT,VAL,LST) 
      NEWVAL = 0.0 
      RETURN 
      END 
      REAL FUNCTION NOATVL(/AT/,/LST/) 
C            NOATVL(AT,L) 
C     THIS FUNCTION REMOVES THE ATTRIBUTE AT AND ITS VALUE FROM THE 
C     DESCRIPTION LIST ASSOCIATED WITH THE LIST L. THE VALUE OF THE FUNC 
C     TION IS THE VALUE ASSOCIATED WITH THAT ATTRIBUTE. 
         M = MADATR(AT,LST) 
      IF(M.EQ.(-1)) GO TO 1
      NOATVL = DELETE(LNKR(M)) 
      JUNK=DELETE(M) 
      RETURN 
1     NOATVL = 0.0 
      RETURN 
      END 
      FUNCTION NUCELL(X) 
      COMMON/SLIPC1/  FAVSLC,LAVSLC 
      INTEGER FAVSLC,STLNKW
      INTEGER ERRDEV /16/
C            NUCELL(DUMMY) 
C     THIS FUNCTION OF NO PARAMETER CAUSES A CELL TO BE TAKEN FROM LAVS 
C     AND ITS MACHINE ADDRESS DELIVERED AS ITS VALUE. 
C     NUCELL DELIVERS THE CONTENTS OF THE LNKR FIELD OF AVSL AS ITS 
C     VALUE,I.E., ASSIGNS THE CELL PAIR THEN ON TOP OF LAVS TO ANSWER 
C     THE NEED, THEN  STORES IN THE LNKR FIELD OF AVSL THE MACHINE 
C     ADDRESS STORED  IN THE LNKR FIELD OF THE FIRST WORD OF THE DESIG- 
C     NATED WORD PAIR. 
C                                                          4/1/63 
      IF (FAVSLC.EQ.0) GO TO 9000
         NUCELL=FAVSLC
         FAVSLC=LNKR(FAVSLC)
         IF (FAVSLC.EQ.0) LAVSLC=0
C...  The cell at the top has a list name as a datum - erase the so mentioned list.
      IF (ID(NUCELL).EQ.1)  IDUM=IRALST(DATUM(NUCELL)) 
C...  The offered cell is zeroed out
      IDUM=STLNKW(0,NUCELL) 
      RDUM=STRDAT(0,NUCELL)
      RETURN 
9000  CONTINUE
      WRITE (ERRDEV,901) 
901   FORMAT(1H1,/6X,55HLIST OF AVAILABLE SPACE EXHAUSTED - PROGRAM TERM 
     1INATED  ) 
           CALL F4TRBK 
         RETURN
      END 
      FUNCTION NULSTL(/LASTC/,/LST/) 
C            NULSTL(LASTC,LST) 
C     THE INPUT PARAMETERS TO THIS FUNCTION ARE LASTC, THE NAME OF A LIST 
C     CELL ON THE LIST LST, AND THE NAME OF THE LIST LST. THE OBJECTIVE OF 
C     THIS FUNCTION IS TO SPLIT THE LIST LST BY CREATING A NEW LIST HAVING 
C     ALL CELLS TO THE LEFT (OR ABOVE) THE CELL INDICATED BY LASTC, AS WELL 
C     AS THE CELL LASTC, AS ITS MEMBERS. THE CELLS THUS ASSOCIATED WITH THE 
C     NEWLY CREATED LIST ARE REMOVED FROM THE LIST L. THE NAME OF THE 
C     NEWLY CREATED LIST IS THE VALUE OF THIS FUNCTION. 
C                                                          4/1/63 
      INTEGER SETIND
      NULSTL = LIST(9) 
      IF (LISTMT(LST).EQ.0) RETURN
      LTOP = LNKR(LST) 
      LSUC = LNKR(LASTC) 
         IDUM=SETIND(-1,-1,LSUC,LST) 
         IDUM=SETIND(-1,LST,-1,LSUC) 
C...
         IDUM=SETIND(-1,LASTC,LTOP,NULSTL) 
         IDUM=SETIND(-1,-1,NULSTL,LASTC) 
         IDUM=SETIND(-1,NULSTL,-1,LTOP) 
      RETURN 
      END 
      FUNCTION NULSTR(/FIRSTC/,/LST/) 
C            NULSTR(FIRSTL,LST) 
C     THE INPUT PARAMETERS TO THIS FUNCTION ARE FIRSTC,THE NAME OF A LIST 
C     CELL ON THE LIST LST, AND THE NAME OF THE LIST LST. THE OBJECTIVE OF 
C     THIS FUNCTION IS TO SPLIT THE LIST LST BY CREATING A NEW LIST HAVING 
C     ALL CELLS TO THE RIGHT OF (OR BELOW) THE CELL FIRSTC, AS WELL AS THE 
C     CELL THE ADDRESS OF WHICH IS FIRSTC,  AS ITS MEMBERS.THE CELLS THUS 
C     ASSOCIATED WITH THE NEWLY CREATED LIST ARE REMOVED FROM THE LIST LST 
C     THE NAME OF THE NEWLY CREATED LIST IS THE VALUE OF THIS FUNCTION. 
C                                                          4/1/63 
      INTEGER FIRSTC,SETIND
      NULSTR = LIST(9) 
      IF (LISTMT(LST).EQ.0) RETURN 
      LBOT = LNKL(LST) 
      LPRE = LNKL(FIRSTC) 
         IDUM=SETIND(-1,LPRE,-1,LST) 
         IDUM=SETIND(-1,-1,LST,LPRE) 
C...
         IDUM=SETIND(-1,LBOT,FIRSTC,NULSTR) 
         IDUM=SETIND(-1,NULSTR,-1,FIRSTC) 
         IDUM=SETIND(-1,-1,NULSTR,LBOT) 
      RETURN 
      END 
      FUNCTION NXTLFT(/DAT/,/NSC/) 
      INTEGER SETDIR,SETMKW,SETIND,DAT
C            NXTLFT(DAT,NSC) 
C     NXTLFT INSERTS THE DATUM DAT TO THE LEFT OF THE LIST CELL 
C      SPECIFIED BY NSC. THE VALUE OF THE 
C     FUNCTION IS THE NAME OF THE CELL TAKEN FROM LAVS FOR 
C     DATUM AND LINKAGE STORAGE. 
C     THIS FUNCTION CHECKS WHETHER THE DATUM BEING PLACED IS A NAME AND 
C     COUNTS THE SUBLIST COUNTER UP WHEN IT IS. 
C                                                          4/1/63 
C...  Get a cell
      NXTLFT = NUCELL(Z) 
C...  Save the LNKL of NSC
      LL = LNKL(NSC) 
C...  Set the LNKR of NSC to point to the new cell.
      IDUM=SETIND(-1,-1,NXTLFT,LL) 
C...  Set the LNKL of NSC to point to the new cell
      IDUM=SETIND(-1,NXTLFT,-1,NSC) 
C...  Set the links of the new cell
      IDUM=SETIND(0,LL,NSC,NXTLFT) 
C...  Does DAT contain a name?
      IF(NAMTST(DAT).NE.0) GO TO 1000 
C...     Yes it is a name; mark the cell accordingly.
         IDUM=SETIND(1,-1,-1,NXTLFT) 
         IDUM=SETMKW(6,NXTLFT)
         DTEMP=DATUM(DAT)
         IDUM=SETDIR(-1,-1,LCNTR(DAT)+1,DTEMP)
         IDUM=STRDAT(DTEMP,DAT)
1000  CONTINUE
C...  Finally! Store DAT in NXTLFT cell.
      IDUM=STRDAT(DAT,NXTLFT)
      RETURN 
      END 
      FUNCTION NXTRGT(/DAT/,/NSC/) 
C            NXTRGT(DAT,NSC) 
C     NXTRGT INSERTS THE DATUM DAT TO THE RIGHT OF THE LIST CELL 
C      SPECIFIED BY NSC. THE VALUE OF THE 
C     FUNCTION IS THE NAME OF THE CELL TAKEN FROM LAVS FOR 
C     DATUM AND LINKAGE STORAGE. 
C     THIS FUNCTION CHECKS WHETHER THE DATUM BEING PLACED IS A NAME AND 
C     COUNTS THE SUBLIST COUNTER UP WHEN IT IS. 
C                                                          4/1/63 
      INTEGER SETDIR,SETMKW,SETIND,DAT
      NXTRGT = NUCELL(Z) 
        LR = LNKR(NSC) 
      IDUM=SETIND(-1,NXTRGT,-1,LR) 
      IDUM=SETIND(-1,-1,NXTRGT,NSC) 
      IDUM=SETIND (0,NSC,LR,NXTRGT) 
         IF (NAMTST(DAT).NE.0) GO TO 1000 
      IDUM=SETIND(1,-1,-1,NXTRGT) 
      IDUM=SETMKW(6,NXTRGT)
      DTEMP=DATUM(DAT)
      IDUM=SETDIR(-1,-1,LCNTR(DAT)+1,DTEMP)
      RDUM=STRDAT(DTEMP,DAT)
1000  CONTINUE
      RDUM=STRDAT(DAT,NXTRGT)
      RETURN 
      END 
      FUNCTION PARMT(N,/A/)
      DIMENSION A(N)
      COMMON /PUBLIC/ LSTPUB(10)
      INTEGER ERRDEV /16/, NPUBL /10/
      IF (N.GT.NPUBL) GO TO 9000
      DO 1000 I=1,N
         IDUM=NEWTOP(A(I),LSTPUB(I))
1000  CONTINUE
      PARMT=A(1)
9000  CONTINUE
      WRITE (ERRDEV,9100) N,NPUB
9100  FORMAT ('0***SLIP-ERROR***  Attempt to use ',I10,
     +'Public Lists where only ',I3,'exist. Program regretfully',
     +' terminated.')
      CALL F4TRBK
         RETURN
      END
      FUNCTION PARMT2(/A/,/B/) 
      COMMON /PUBLIC/ LSTPUB(10) 
C            PARMT2(X,Y) 
C     THIS SUBROUTINE CAUSES THE INPUT PARAMETERS SPECIFIED TO BE PUSHED 
C     DOWN ON LSTPUB(1) AND LSTPUB(2) RESPECTIVELY. ITS UTILITY IS MAINLY IN THAT 
C     IT AIDS IN THE COMMUNICATION OF PARAMETERS FOR RECURSION. 
C                                                          4/1/63 
      IDUM=NEWTOP(A,LSTPUB(1)) 
      IDUM=NEWTOP(B,LSTPUB(2)) 
      PARMT2 = A 
      RETURN 
      END 
      FUNCTION POPBOT(/LSTNAM/) 
C            POPBOT(L) 
C     THE BOTTOM CELL OF THE LIST WHOSE NAME IS THE INPUT PARAMETER TO 
C     THIS FUNCTION IS 'POPPED OFF' THAT LIST AND THE DATUM CONTAINED 
C     THEREIN DELIVERED AS THE VALUE OF THE FUNCTION. 
C                                                          4/1/63 
      POPBOT = DELETE(LNKL(LOCT(LSTNAM))) 
      RETURN 
      END 
      FUNCTION POPTOP(/LSTNAM/) 
C            POPTOP(LSTNAM) 
C     THE TOP CELL OF THE LIST WHOSE NAME IS THE INPUT PARAMETER TO THIS 
C     FUNCTION IS 'POPPED OFF' THAT LIST,I.E., RETURNED TO LAVS, AND THE 
C     DATUM CONTAINED THEREIN DELIVERED AS THE VALUE OF THE FUNCTION. 
C                                                          4/1/63 
      POPTOP = DELETE(LNKR(LOCT(LSTNAM))) 
        RETURN 
        END 
      SUBROUTINE PRESRV(N) 
      COMMON /PUBLIC/ LSTPUB(10) 
C            PRESRV(N) 
C     THE INPUT TO THIS FUNCTION IS AN INTEGER N (LESS THAN OR EQUAL TO 
C     10). THIS FUNCTION 'PRESERVES' THE FIRST N OF THE 10 PUBLIC 
C     LISTS W,I.E., LSTPUB(1),LSTPUB(2),...,LSTPUB(N). TO PRESERVE A LIST , IN THE 
C     INTENDED SENSE, MEANS TO PUSH WHATEVER DATUM IS PRESENTLY ON ITS 
C     TOP ON ITS TOP ONCE MORE. THE FIRST TWO CELLS OF A PRESERVED LIST 
C     ARE THEREFORE IDENTICAL (AS SEEN BY THE PROGRAMMER). 
C                                                          4/1/63 
      DO 1 I=1,N 
    1 IDUM=NEWTOP(TOP(LSTPUB(I)),LSTPUB(I)) 
      RETURN 
      END 
      SUBROUTINE PRLSTS(/OUTLST/,IFORM) 
      DOUBLE PRECISION FORMIT(1),FORM(4)
      INTEGER OUTLST
      INTEGER LPTDEV,READER,RLEVEL,IDATM
C     LPTDEV IS OUTPUT UNIT 
      DATA LPTDEV/14/,FORM /'(5X,I14)','(F19.8 )','(15X,A4)','(11X,Z8)'/
C...  Put out a title.
      WRITE (LPTDEV,900) 
C...
      IF (LISTMT(OUTLST).EQ.0) GO TO 9000
      READER=LRDROV(OUTLST) 
      LEVEL = 0 
      IF(IFORM.GT.4)IFORM=4
      FORMIT(1)=FORM(IFORM) 
1000  CONTINUE 
         DATM=ADVSWR(READER,IFLAG) 
         RLEVEL=LCNTR(READER)
         IF (RLEVEL.GE.LEVEL) GO TO 3000
            LDIFF=LEVEL-RLEVEL
            DO 2000 I=1,LDIFF
               WRITE (LPTDEV,903)
2000        CONTINUE
            LEVEL=RLEVEL
            GO TO 3000
3000     CONTINUE
C....
         IF(IFLAG.NE.0) GO TO 6000 
C...        Has a listname been encountered? 
            IF (NAMTST(DATM).EQ.0) GO TO 4000 
C...           Print according to the format specified. 
               WRITE (LPTDEV,FORMIT) DATM 
               GO TO 5000 
4000        CONTINUE 
C...           A list name has been encountered. 
               LEVEL=LEVEL+1 
C...           Print a sub-list header. 
               WRITE (LPTDEV,902) 
C...           Is the sublist empty? 
               IF (LISTMT(DATM).EQ.0) WRITE (LPTDEV,904) 
               GO TO 5000 
5000        CONTINUE 
            GO TO 7000 
6000     CONTINUE 
            IDUM=IRARDR(READER) 
         GO TO 9000 
7000     CONTINUE 
8000  CONTINUE
         GO TO 1000
9000  CONTINUE
         WRITE (LPTDEV,901)
      RETURN
900   FORMAT (//3X,'BEGIN LIST') 
901   FORMAT (3X,'END LIST'//) 
902   FORMAT (5X,'BEGIN  SUBLIST') 
903   FORMAT (5X,'END    SUBLIST') 
904   FORMAT (5X,' EMPTY SUBLIST') 
      END 
      SUBROUTINE RCELL(/NSC/) 
      INTEGER FAVSLC,SETIND
      COMMON /SLIPC1/  FAVSLC,LAVSLC
C            RCELL(A) 
C     THIS SUBROUTINE RETURNS THE CELL THE ADDRESS OF WHICH IS GIVEN BY 
C     NSC TO LAVS. 
C     IN PARTICULAR, CELLS ARE ATTACHED TO THE BOTTOM OF LAVS BY MEANS 
C     OF SUITABLE MODIFICATION OF AVSL, AND OF LNKR OF THE CELL PREVIOUS 
C     LY ON THE BOTTOM OF LAVS. 
      IF(LAVSLC.NE.0) IDUM=SETIND(-1,-1,NSC,LAVSLC)
      LAVSLC=NSC
      IF (FAVSLC.EQ.0) FAVSLC=LAVSLC
C...  Set the LNKR of the released cell to zero
      IDUM=SETIND(-1,-1,0,NSC) 
      RETURN 
      END 
      FUNCTION RDLSTA(DUMMY)
      INTEGER STACK,BUFFER,CURLST,OUTDEV
      INTEGER LPAREN,RPAREN,BLANK,TERMNL,CRDBUF,SYMBOL,COMMA,PUTRDL,CURLST,TEMP
      LOGICAL FPAREN
      DIMENSION CRDBUF(72)
      EQUIVALENCE (NL6000,L6000),(NL7000,L7000)
           DATA INDEV/17/,OUTDEV/18/
      DATA BLANK  /'    '/
      DATA LPAREN /'(   '/
      DATA RPAREN /')   '/
      DATA COMMA  /',   '/
      DATA TERMNL /'*   '/
      DATA MAXSYM /72/
C...  Initialize BUFFER to blanks.
      BUFFER=BLANK
      FPAREN=.FALSE.
      NBUF=0
      RDLSTA=0.0 
      STACK=LIST(STACK)
100   CONTINUE
      READ  (INDEV,9997,END=9000) (CRDBUF(J),J=1,MAXSYM)
      WRITE (OUTDEV,9998) (CRDBUF(J),J=1,MAXSYM)
C...
C...
      DO 8000 IC=1,MAXSYM
         SYMBOL=CRDBUF(IC)
         IF (SYMBOL.EQ.LPAREN) GO TO 1000
         IF (SYMBOL.EQ.BLANK)  GO TO 3000
            IF(.NOT.FPAREN) GO TO 9500
         IF (SYMBOL.EQ.COMMA)  GO TO 4000
         IF (SYMBOL.EQ.RPAREN) GO TO 5000
         IF (SYMBOL.EQ.TERMNL) GO TO 6000
         GO TO 2000
C...
C...
1000     CONTINUE
C...     Symbol is left parenthesis.
C...        Is something in the buffer ?
            IF (BUFFER.NE.BLANK) NBUF=PUTRDL(BUFFER,CURLST)
C...        Create the LIST or SUBLIST. 
C...        Is the MAIN LIST already established? 
            IF (FPAREN) GO TO 1110 
C...           This is the first left paren. should come here once only.
C...           Assign the list-name to RDLSTA.
               FPAREN=.TRUE. 
               CURLST=LIST(RDLSTA) 
               IDUM=NXTRGT(CURLST,STACK) 
               ASSIGN 7000 TO L7000 
               RDUM=VISIT(NL7000)
C...           Control is returned here when that right parenthesis 
C...           matching the first left one is encountered. 
               GO TO 9000 
1110     CONTINUE 
C...        Left parentheses other than first are processed here. 
C...        A SUBLIST must be created and its name 
C...        placed on the current LIST 
            TEMP=0 
            IDUM=NEWBOT(LIST(TEMP),CURLST) 
            CURLST=TEMP 
C...        Push the current LIST name on top of the stack 
            IDUM=NEWTOP(TEMP,STACK) 
            ASSIGN 6000 TO L6000 
            IDUM=IVISIT(NL6000)
C...        Control is passed here when each inner right 
C...        parenthesis is encountered 
            RDUM=POPTOP(STACK) 
            CURLST=INTGER(TOP(STACK)) 
            IF (SYMBOL.EQ.TERMNL) RDUM=TERM(RDUM)
            GO TO 7000 
C...       End of left parenthesis processing. 
C...
C...
2000     CONTINUE
C...        Regular symbol processing.
            NBUF=NBUF+1
            IF (NBUF.LE.4) CALL TRNST(BUFFER,4,' ',SYMBOL,1,NDUM,DUMMY)
            GO TO 7000
C...        End of regular symbol processing.
3000     CONTINUE
C...        Here blanks are processed.
            GO TO 7000
4000     CONTINUE
C...        Comma is encountered. Just clear the buffer.
            IF ((BUFFER.NE.BLANK).OR.
     .            (CRDBUF(IC-1).EQ.COMMA)) NBUF=PUTRDL(BUFFER,CURLST)
C...        End of comma processing
            GO TO 7000
5000     CONTINUE
C...        Begin processing right parenthesis.
            IF (BUFFER.NE.BLANK) NBUF=PUTRDL(BUFFER,CURLST)
            CALL TERM(DUMMY)
C...        TERM passes control to last "VISITed" plus 1.
6000     CONTINUE
C...        If asterisk is encountered before parenthesis
C...        were balanced it will be necessary to unravel stacks.
            IF (SYMBOL.EQ.TERMNL) GO TO 5000
7000     CONTINUE
8000  CONTINUE
C... 
C...  Process another input line.
      GO TO 100
C...
9000  CONTINUE
        IDUM=IRALST(STACK)
        RETURN
C...
9500  CONTINUE
C...     Bad input format - no leading left parenthesis 
         WRITE(OUTDEV,9999) 
C...     Go back to read another line of input 
         GO TO 100 
9997  FORMAT(72A1)
9998  FORMAT('0',72A1)
9999  FORMAT(' ',' BAD INPUT TO RDLSTA')
      END
      FUNCTION PUTRDL(/WHAT/,/WHERE/)
      INTEGER PUTRDL,WHERE
      DATA BLANK /'    '/
      IDUM=NXTLFT(WHAT,WHERE)
      WHAT=BLANK
      PUTRDL=0
      RETURN
      END
      FUNCTION REED(LRD) 
C            REED(LRD) 
C     THE INPUT PARAMETER TO THIS FUNCTION IS A READER.THE VALUE OF THE 
C     FUNCTION IS THE DATUM CONTAINED IN THECELL TO WHICH THE LPNTR OF 
C     THE READER IS CURRENTLY POINTING. THE READER IS NOT MODIFIED IN 
C     ANY WAY. THIS FUNCTION MAY BE CONSIDERED A NULL ADVANCE. 
C                                                          4/1/63 
      REED = DATUM(LNKL(LRD)) 
      RETURN 
      END 
      FUNCTION RESTOR(N) 
      INTEGER ERRDEV
      DATA RESTOR /10./,ERRDEV/16/
      COMMON /PUBLIC/ LSTPUB(10) 
C            RESTOR(N) 
C     THE RESTOR SUBROUTIONE UNDOES THE WORK OF THE PRESRV SUBROUTINE, 
C     I.E., IT 'POPS UP' THE FIRST N PUBLIC LISTS. 
C                                                          4/1/63 
      IF(N.GT.10) GO TO 200
      DO 100 I=1,N 
      RDUM=POPTOP(LSTPUB(I)) 
100   CONTINUE
      RETURN 
200   CONTINUE
      WRITE(ERRDEV,900) N
      CALL F4TRBK
      RETURN
900   FORMAT (' This version of SLIP has only 10 Public Lists; ',
     .'asking to restore ',I10,' Program regretfully terminated.')
      END 
      FUNCTION SEQLL(S,F) 
      INTEGER F,S
C            SEQLL(S,F) 
C     THE LPNTR IS ADVANCED TO THE  LEFT  (UP) . F IS SET TO MINUS ONE 
C     IF THE DATUM LOCATED ON THE LIST IS AN ELEMENT (A NON-NAME), TO 
C     ZERO IF IT IS A NAME, AND TO ONE IF IT IS A HEADER. THE SEQLR 
C     OPERATION CAN THEREFORE BE INTERROGATED BY AN IF STATEMENT-- 
C            IF(F) I,J,K 
C     IF THE CELL FOUND IS A HEADER, THE VALUE OF THE FUNCTION IS ZERO. 
C     OTHERWISE, THE VALUE IS THE DATUM CONTAINED IN THE CELL. 
      L=LNKL(S) 
      S=L
      SEQLL=DATUM(L) 
      IF (ID(L)-1) 10,20,30 
10    F = -1 
       RETURN 
20    F = 0 
      RETURN 
30    F = 1 
      SEQLL=0.0
      RETURN 
      END 
      FUNCTION SEQLR(S,F) 
      INTEGER F,S
C            SEQLR(S,F) 
C     THE LPNTR IS ADVANCED TO THE RIGHT (DOWN). F IS SET TO MINUS ONE 
C     IF THE DATUM LOCATED ON THE LIST IS AN ELEMENT (A NON-NAME), TO 
C     ZERO IF IT IS A NAME, AND TO ONE IF IT IS A HEADER. THE SEQLR 
C     OPERATION CAN THEREFORE BE INTERROGATED BY AN IF STATEMENT-- 
C            IF(F) I,J,K 
C     IF THE CELL FOUND IS A HEADER, THE VALUE OF THE FUNCTION IS ZERO. 
C     OTHERWISE, THE VALUE IS THE DATUM CONTAINED IN THE CELL. 
      L=LNKR(S) 
      S=L
      SEQLR = DATUM(L) 
      IF (ID(L)-1) 10,20,30 
10    F = -1 
       RETURN 
20    F = 0 
      RETURN 
30    F = 1 
      SEQLR=0.0
      RETURN 
      END 
      FUNCTION SEQRDR(/LST/) 
      INTEGER SEQRDR
C            SEQRDR(LST) 
C     THE STATEMENT S=SEQRDR(LST) CAUSES S TO BE A SEQUENCE READER OF 
C     THE LIST LST. THAT IS, SEQRDR IS A FUNCTION THE VALUE OF WHICH IS 
C     A SINGLE COMPUTER WORD IN THE SEQUENCE READER FORMAT. IT MAY 
C     TRAVERSE A LIST OR LIST STRUCTURE IN MUCH THE SAME WAY AS A READER 
C     BUT IT DOES NOT STORE HISTORICAL INFORMATION WITH RESPECT TO ITS 
C     DESCENTS INTO LIST STRUCTURES AND IS THEREFORE NOT ABLE TO 
C     ASCEND FROM A SUBLIST INTO A MAIN LIST. THE SEQUENCE READER IS NOT 
C     TAKEN FROM LAVS AND NEED NOT BE ERASED. 
      SEQRDR=LNKLW(LOCT(LST)) 
      RETURN 
      END 
      FUNCTION SEQSL(S,F) 
      INTEGER F,S
C            SEQSL(S,F) 
C     THE LPNTR OF THE SEQUENCE READER IS ADVANCED TO THE  LEFT  (UP). 
C      THE ENCOUNTER OF A HEADER ON ANY LEVEL CAUSES THE FLAG F TO BE 
C     SET TO ONE, BUT NO ASCENSION WITHIN THE LIST STRUCTURE. THE 
C     ENCOUNTER OF A LIST NAME CAUSES A DESCENT INTO THE LIST STRUCTURE 
C     HOWEVER. THE FLAG F IS SET TO A MINUS ONE IF THE CELL ENCOUNTERED 
C     IS AN ELEMENT (A NON-NAME).THE VALUE OF THE FUNCTION IS ZERO IF 
C     THE CELL ENCOUNTERED IS A HEADER, AND IS THE DATUM IN THE CELL IF 
C     IT IS AN ELEMENT. 
         IF (ID(S).NE.1) GO TO 1000
         S=LNKLW(DATUM(S))
         GO TO 2000
1000  CONTINUE
         S=LNKL(S)
2000  CONTINUE
         IF (ID(S).NE.1) GO TO 3000
         S=LNKLW(DATUM(S))
3000  CONTINUE
         SEQSL=DATUM(S)
         F=ID(S)-1
         IF (F.EQ.1) SEQSL=0.0
      RETURN 
      END 
      FUNCTION SEQSR(S,F) 
      INTEGER F,S
C            SEQSR(S,F) 
C     THE LPNTR OF THE SEQUENCE READER S ISADVANCED TO THE RIGHT (DOWN). 
C      THE ENCOUNTER OF A HEADER ON ANY LEVEL CAUSES THE FLAG F TO BE 
C     SET TO ONE, BUT NO ASCENSION WITHIN THE LIST STRUCTURE. THE 
C     ENCOUNTER OF A LIST NAME CAUSES A DESCENT INTO THE LIST STRUCTURE 
C     HOWEVER. THE FLAG F IS SET TO A MINUS ONE IF THE CELL ENCOUNTERED 
C     IS AN ELEMENT (A NON-NAME).THE VALUE OF THE FUNCTION IS ZERO IF 
C     THE CELL ENCOUNTERED IS A HEADER, AND IS THE DATUM IN THE CELL IF 
C     IT IS AN ELEMENT. 
         IF (ID(S).NE.1) GO TO 1000
         S=LNKRW(DATUM(S))
         GO TO 2000
1000  CONTINUE
         S=LNKR(S)
2000  CONTINUE
         IF (ID(S).NE.1) GO TO 3000
         S=LNKRW(DATUM(S))
3000  CONTINUE
         SEQSR=DATUM(S)
         F=ID(S)-1
         IF (F.EQ.1) SEQSR=0.0
      RETURN 
      END 
      FUNCTION SUBSBT(/DAT/,/LST/) 
C            SUBSBT(P,M) 
C     THE DATUM P REPLACES THE DATUM PRESENTLY STORED ON THE BOTTOM OF 
C     THE LIST M. THE VALUE OF THIS FUNCTION IS THE DATUM REPLACED BY IT 
C     I.E., THE PREVIOUS CONTENTS OF THE BOTTOM OF THE LIST. 
C                                                          4/1/63 
         SUBSBT = SUBST(DAT,LNKL(LST)) 
      RETURN 
      END 
      FUNCTION SUBST(/DAT/,/CADR/) 
      INTEGER CADR,SETDIR
C            SUBST(DAT,CADR) 
C     THE DATUM P REPLACES THAT STORED IN THE LIST CELL WHOSE ADDRESS IS 
C     SPECIFIED BY CADR. THE REPLACED DATUM IS THE VALUE OF THIS FUNCTION. 
C                                                          4/1/63 
C...  This version of SUBST (by B. Herzog, January 1974) differs from
C...  Weizenbaum's. It avoids the problems that occur when a READER is left
C...  pointing to the cell whose datum is being changed. Weizenbaum's
C...  specification is still satisfied - the warning is released.
C...
C...
      DATEMP=DATUM(CADR)
C...  Now determine if DATEMP refers to a list - if so erase it
      IF(NAMTST(DATEMP).EQ.0) IDUM=IRALST(DATEMP)
C...  Now determine if DAT refers to a list - if so increase counter
      IF(NAMTST(DAT).NE.0) GO TO 100
C...  It is a list name - get its header's datum
      DTEMP=DATUM(DAT)
C...  Now increase its LCNTR
      IDUM=SETDIR(-1,-1,LNKR(DTEMP)+1,DTEMP)
C...  Now put it back
      RDUM=STRDAT(DTEMP,DAT)
100   CONTINUE
C...  Put the new datum in CADR
      RDUM=STRDAT(DAT,CADR)
      SUBST=DATEMP
      RETURN 
      END 
      FUNCTION SUBSTP(/DAT/,/LSTNAM/) 
C            SUBSTP(DAT,M) 
C     THE DATUM DAT REPLACES THE DATUM PRESENTLY ON TOP OF THE LIST M. THE 
C     VALUE OF THIS FUNCTION IS THE DATUM REPLACED BY IT,I.E., THE 
C     PREVIOUS CONTENTS OF THE TOP OF THE LIST M. 
C                                                          4/1/63 
         SUBSTP = SUBST(DAT,LNKR(LSTNAM)) 
      RETURN 
      END 
      FUNCTION TOP(/L/) 
C                                                          4/1/63 
C            TOP(L) 
C     THE INPUT PARAMETER TO THE FUNCTION TOP IS THE NAME OF A LIST. ITS 
C     VALUE IS THE DATUM STORED ON THE TOP (LEFTMOST) CELL ON THAT LIST. 
C     THE LIST IS NOT MODIFIED BY THIS OPERATION. 
      TOP = DATUM(LNKR(LOCT(L))) 
      RETURN 
      END 
      SUBROUTINE INITAS(SPACE,NPAR)
      DIMENSION SPACE(1),J(3)
      INTEGER ADROF,BYTPWD
      INTEGER ERRDEV /16/
      DATA IDEFSZ/8192/
C...  Fix the number of bytes per word.
      DATA BYTPWD /4/
      EXTERNAL GETSPA,ADROF,INTSVM
      IF(NPAR.GT.0)GOTO 1000 
      IF (NPAR.EQ.0) N=IDEFSZ
      IF (NPAR.LT.0) N=(((IABS(NPAR)/4096)+1)*4096)
      CALL RCALL(GETSPA,3,0,N*BYTPWD+117440512,7,2,Q,J,&600)
      J(2)=ADROF(N)
      J(3)=ADROF(0)
      CALL RCALL(INTSVM,2,0,ADROF(J),0)
      RETURN
1000  CONTINUE
      CALL INTSVM(SPACE,NPAR)
      RETURN
600   WRITE(ERRDEV,100) 
100   FORMAT('**** SLIP ERROR; GETSPACE FAILED **')
      CALL F4TRBK
      END
      SUBROUTINE INTSVM(SPACE,NSPACE) 
      INTEGER ENDPUB,SPACE,FAVSLC,SETDIR,CRESVM,HIREF,VISTIN
      DATA ENDPUB/10/,HIREF /4095/
      COMMON /SLIPC1/  FAVSLC,LAVSLC 
      COMMON /PUBLIC/ LSTPUB(10)
      DIMENSION SPACE(1)
C            INITAS(SPACE,N) 
C     THIS SUBROUTINE TRANSFORMS THE SINGLE DIMENSIONAL ARRAY, SPACE, 
C     (PREVIOUSLY DECLARED BY A DIMENSION STATEMENT WRITTEN BY THE 
C     PROGRAMMER) OF LENGTH NSPACE SUCH THAT THE LNKR FIELD OF EVERY ODD 
C     NUMBERED WORD CONTAINS THE NAME OF THE NEXT CELL 
C     EXCEPT FOR THE (N-1)ST WORD WHICH IS ZERO.ALL 
C     OTHER FIELDS OF WORDS IN THE ARRAY ARE SET TO ZERO. 
C     INTERNAL TO THE SYSTEM FAVSL 
C     CONTAINS THE NAME OF THE FIRST CELL OF LAVS, AND LAVSLC 
C      THE NAME OF THE LAST CELL OF LAVS. 
C      A SET OF EMPTY LISTS WITH 
C     ALIASES LSTPUB(1),LSTPUB(2),...,LSTPUB(10),RESPECTIVELY WILL BE CREATED. 
C      ANY SUBPROGRAM 
C     WHICH REQUIRES ACCESS TO ANY OF THE PUBLIC LISTS MUST DECLARE THEM 
C     BY MEANS OF THE FOLLOWING COMMON STATEMENT-- 
C            COMMON /PUBLIC/  LSTPUB(10) 
C                                                          4/1/63 
      FAVSLC=1
      LAVSLC=NSPACE/2
      NSCEND=NSPACE-3
      NSC=1
      DO 100 I=1,NSCEND,2
         NSC=NSC+1
         SPACE(I)=0
         SPACE(I+1)=0
         IDUM=SETDIR(-1,-1,NSC,SPACE(I))
100   CONTINUE
      SPACE(NSPACE-1)=0
      SPACE(NSPACE)=0
      IDUM=CRESVM(SPACE(1))
      DO 400 I=1,ENDPUB
         LSTPUB(I)=LIST(9)
C        ITEMP=IDATUM(LSTPUB(I))
C        IDUM=SETDIR(-1,-1,HIREF,ITEMP)
C        RDUM=STRDAT(ITEMP,LSTPUB(I))
      RDUM=STRDAT(SETDIR(-1,-1,HIREF,IDATUM(LSTPUB(I))),LSTPUB(I))
400   CONTINUE
      ISTACK=VISTIN(IDUM)
      CALL DMPINI(LAVSLC)
      RETURN
      END 
      SUBROUTINE SLPDMP(DUMMY1,DUMMY2) 
C 
C  SSSSSSSSSS   LL             IIIIIIIIII   PPPPPPPPPPP 
C SSSSSSSSSSSS  LL             IIIIIIIIII   PPPPPPPPPPPP 
C SS        SS  LL                 II       PP        PP 
C SS            LL                 II       PP        PP 
C SSS           LL                 II       PP        PP 
C  SSSSSSSSS    LL                 II       PPPPPPPPPPPP 
C   SSSSSSSSS   LL                 II       PPPPPPPPPPP 
C          SSS  LL                 II       PP 
C           SS  LL                 II       PP 
C SS        SS  LL                 II       PP 
C SSSSSSSSSSSS  LLLLLLLLLLLL   IIIIIIIIII   PP 
C  SSSSSSSSSS   LLLLLLLLLLLL   IIIIIIIIII   PP 
C 
C 
C DDDDDDDDD     UU        UU  MM        MM  PPPPPPPPPPP 
C DDDDDDDDDD    UU        UU  MMM      MMM  PPPPPPPPPPPP 
C DD       DD   UU        UU  MMMM    MMMM  PP        PP 
C DD        DD  UU        UU  MM MM  MM MM  PP        PP 
C DD        DD  UU        UU  MM  MMMM  MM  PP        PP 
C DD        DD  UU        UU  MM   MM   MM  PPPPPPPPPPPP 
C DD        DD  UU        UU  MM        MM  PPPPPPPPPPP 
C DD        DD  UU        UU  MM        MM  PP 
C DD        DD  UU        UU  MM        MM  PP 
C DD       DD   UU        UU  MM        MM  PP 
C DDDDDDDDDD    UUUUUUUUUUUU  MM        MM  PP 
C DDDDDDDDD      UUUUUUUUUU   MM        MM  PP 
C 
C 
C PPPPPPPPPPP   KK        KK   GGGGGGGGGG 
C PPPPPPPPPPPP  KK       KK   GGGGGGGGGGGG 
C PP        PP  KK      KK    GG        GG 
C PP        PP  KK     KK     GG 
C PP        PP  KK    KK      GG 
C PPPPPPPPPPPP  KKKKKKK       GG 
C PPPPPPPPPPP   KKKKKKK       GG     GGGGG 
C PP            KK    KK      GG     GGGGG 
C PP            KK     KK     GG        GG      .... 
C PP            KK      KK    GG        GG      .... 
C PP            KK       KK   GGGGGGGGGGGG      .... 
C PP            KK        KK   GGGGGGGGGG       .... 
C 
C...  REPROGRAMMED BY B. HERZOG, October 1974
      INTEGER DMPDEV /15/
      ENTRY DMPSVM
C...  Ready to print the SLIP-DUMP header
1000  WRITE (DMPDEV,1010) 
1010  FORMAT ('1',T24,' ****** SLIP DUMP ******'/'0'//) 
C...  Process the List of Available Space.
      CALL DMPLAV
C...  Process the READERS
      CALL DMPRDR(MAXNSC)
C...  Process Public Lists
      CALL DMPUBL
C...  Process the Lists
      CALL DMPLST(MAXNSC)
C...  Process all the FREE CELLS
      CALL DMPFRE(MAXNSC)
C...  Restore all the ID's
      CALL DMPRES(MAXNSC)
      WRITE(DMPDEV,9902)
      RETURN
9902  FORMAT ('1')
      ENTRY DMPINI(IARG)
      MAXNSC=IARG
      RETURN
      END
      SUBROUTINE DMPLAV
      INTEGER FAVSLC
      LOGICAL SAME,TITLE
      COMMON /SLIPC1/ FAVSLC,LAVSLC
      INTEGER DMPDEV /15/
C...  Ready to print the LAVS header
      WRITE (DMPDEV,9100) 
      TITLE=.FALSE.
      IF(FAVSLC.EQ.0) GO TO 9000
      WRITE (DMPDEV,9300) FAVSLC,LAVSLC 
      LINK=FAVSLC
      LINKPV=FAVSLC
      IDUP=0
1000  CONTINUE
         LINK=LNKR(LINK) 
         IF(LINK.EQ.0) GO TO 5000 
         CALL DMPER1(LINK)
         SAME=(((LINK-LINKPV).EQ.1).AND.(DATUM(LINK).EQ.DATUM(LINKPV)))
         IF(SAME) GO TO 2000
            IF(IDUP.GT.1) WRITE(DMPDEV,9400) 
            IF (IDUP.GT.0) IDUP=0 
            GO TO 3000
2000     CONTINUE
            IDUP=IDUP+1
            IF (IDUP.GT.1) GO TO 4000
3000        CONTINUE
            CALL DMP(LINKPV,TITLE) 
4000        CONTINUE
               CALL DMPMRK(LINKPV)
               LINKPV=LINK
      GO TO 1000
5000  CONTINUE
      IF(IDUP.GT.1) WRITE(DMPDEV,9400)
      CALL DMP(LINKPV,TITLE)
      CALL DMPMRK(LINKPV)
      RETURN
9000  CONTINUE
      WRITE (DMPDEV,9200) 
      RETURN
9100  FORMAT (' AVAILABLE SLIP STORAGE'/'0'/) 
9200  FORMAT (' **NONE AVAILABLE**'/'0'/) 
9300  FORMAT (' FIRST AVAILABLE CELL IS',T26,I6,/
     1' LAST  AVAILABLE CELL IS',T26,I6/'0'/) 
9400  FORMAT(T3,'......')
      END
      SUBROUTINE DMPRDR(MAXNSC)
      LOGICAL TITLE,DMPLNK
      INTEGER DMPDEV /15/,IDRDR/3/
C...  Now begin processing the READERS
C...  Print the READER header
      TITLE=.FALSE.
      NSCBEG=1
      WRITE (DMPDEV,9100) 
1000  CONTINUE
      IF (.NOT.DMPLNK(NSC,IDRDR,NSCBEG,MAXNSC)) GO TO 9000
         NSCBEG=NSC
2000     CONTINUE
            CALL DMP(NSC,TITLE)
            CALL DMPMRK(NSC)
            NSC=LNKR(NSC)
            IF (NSC.EQ.0) GO TO 3000
               GO TO 2000
3000  CONTINUE
      GO TO 1000
9000  CONTINUE 
      IF(.NOT.TITLE) WRITE (DMPDEV,9200) 
      RETURN
9100  FORMAT ('2',// ' READERS'/'0'/) 
9200  FORMAT (' **NO READERS IN USE**'//) 
      END
      SUBROUTINE DMPLST(MAXNSC)
C...  Begin processing the lists
      LOGICAL DMPLNK,TITLE
C...  IDTYPE for list is the HEADER ID
      DATA IDLIST/2/
      INTEGER DMPDEV /15/
      TITLE=.FALSE.
      NSCBEG=1
      WRITE (DMPDEV,9100) 
1000  CONTINUE
         IF (.NOT.DMPLNK(NSC,IDLIST,NSCBEG,MAXNSC)) GO TO 9000
         CALL DMPLIS(NSC,TITLE)
         NSCBEG=NSC
      GO TO 1000
9000  CONTINUE 
      IF (.NOT.TITLE) WRITE (DMPDEV,9200) 
      RETURN
9100  FORMAT ('1',//' LISTS'/'0'/) 
9200  FORMAT (' **NO HEADERS IN USE - NO LISTS**'//) 
      END
      SUBROUTINE DMPUBL
C...  Begin processing the PUBLIC LISTS
      LOGICAL TITLE
      COMMON /PUBLIC/  LSTPUB(10) 
      INTEGER DMPDEV /15/
      TITLE=.FALSE.
      WRITE (DMPDEV,9100) 
      DO 1000 I= 1,10 
         CALL DMPLIS(LSTPUB(I),TITLE)
1000  CONTINUE 
      RETURN
9100  FORMAT ('2',//' PUBLIC LISTS'/'0'/) 
      END
      SUBROUTINE DMPFRE(MAXNSC)
      LOGICAL TITLE
C...  Begin processing any free cells
      INTEGER DMPDEV /15/
      TITLE=.FALSE.
      WRITE (DMPDEV,9100) 
      DO 2000 NSC=1,MAXNSC
         IF (ID(NSC).GE.3) GO TO 1000 
         CALL DMP(NSC,TITLE) 
1000     CONTINUE
2000  CONTINUE 
      IF (.NOT.TITLE) WRITE (DMPDEV,9200)
      RETURN
9100  FORMAT ('2',//' FREE CELLS'//) 
9200  FORMAT (' **NO FREE CELLS IN USE**'//) 
      END
      LOGICAL FUNCTION DMPLNK(NSC,IDCAND,MEMBEG,MEMEND)
      DO 1000 NSC=MEMBEG,MEMEND
         IDTEST=ID(NSC)
         IF (IDTEST.EQ.IDCAND) GO TO 2000
1000  CONTINUE
      DMPLNK=.FALSE.
      RETURN
2000  CONTINUE
      DMPLNK=.TRUE.
      RETURN
      END
      SUBROUTINE DMPLIS(LISTNA,TITLE)
      LOGICAL TITLE
      LNSC=LNKRW(LISTNA)
      NSC=LNSC
1000  CONTINUE
         CALL DMPERR(NSC)
         CALL DMP(NSC,TITLE) 
         CALL DMPMRK(NSC)
         NSC = LNKR(NSC) 
         IF (NSC .EQ. LNSC) RETURN 
      GO TO 1000
      END
      SUBROUTINE DMPRES(MAXNSC)
      INTEGER SETIND
C...  Restore all the ID's
      DO 1000 NSC=1,MAXNSC 
         II=ID(NSC) 
         IDUM=SETIND(II-II/4*4,-1,-1,NSC) 
1000  CONTINUE 
      RETURN
      END
      SUBROUTINE DMPMRK(LINK)
      INTEGER SETIND
C...  Every SLIP cell dumped is marked by incrementing its ID by 4.
      IDUM=SETIND(4+ID(LINK),-1,-1,LINK)
      RETURN
      END
      SUBROUTINE DMP(NSC,TITLE) 
      LOGICAL TITLE
      INTEGER TSYM,TYPE,CDATM
      EQUIVALENCE(DATM,IDATM)
      DIMENSION TSYM(4)
      DATA TSYM/' DAT',' NAM',' HDR',' RDR'/
      INTEGER DMPDEV/15/
      IF(TITLE) GO TO 1000
         IF(.NOT.TITLE) WRITE (DMPDEV,9900)
            TITLE=.TRUE.
1000  CONTINUE
C...     Set things up
         NSCELL = NSC 
         ID1=ID(NSC) 
         TYPE=TSYM(ID1+1) 
         LNKL1 = LNKL(NSC) 
         M1=MRK(NSC) 
         LNKR1 = LNKR(NSC) 
         DATM=DATUM(NSC)
         CDATM=0
         CALL DMPCHR(IDATM,CDATM)
         ID2=IDW(DATM) 
         LNKL2 = LNKLW(DATM) 
         M2=MRKW(DATM) 
         LNKR2=LNKRW(DATM)
C...  If it is a header or reader we space
      IF(ID1.GE.2) WRITE(DMPDEV,9777)
C...  We print 
      WRITE(DMPDEV,9000) NSCELL,TYPE,ID1,LNKL1,M1,
     .LNKR1,IDATM,CDATM,DATM,IDATM,
     .ID2,LNKL2,M2,LNKR2
      RETURN
C...           NSCELL TYPE  ID1    LNKL1  M1     LNKR1  HEX    DATM 
9000  FORMAT(1X,T2,I6,T9,A4,T14,I2,T17,I6,T24,I1,T26,I6,T34,Z8,T43,A4
C...   REAL      INT     ID2    LNKL2  M2    LNKR
     .,T48,E13.6,T62,I11,T74,I2,T77,I6,T84,I1,T86,I6)
9900  FORMAT(' CELL   TYPE <---LINK  WORD--->  <',22(1H-),' D A T U M ',
     .23(1H-),'>',//' NUMBER',
     .T14,'ID',T17,'  LNKL',T24,'M',T26,'  LNKR',T34,'HEX',T43,'CHAR',
     .T48,'<REAL  VALUE>',T62,'< INTEGER >',T74,'ID',
     .T77,'  LNKL',T84,'M',T86,'  LNKR')
9777  FORMAT(' ')
      END
      SUBROUTINE DMPCHR(IARG1,IARG2)
C...  This function converts non-printable characters, i.e., 
C...  headecimal combinations, to blanks.  Used in dumping 
C...  SLIP memory.
      INTEGER IDATM,CDATM
      LOGICAL*1 CHARIN(4),CAROUT(4),TCAR4(4),TCAR1
      EQUIVALENCE (INDEX,TCAR4(1)),(TCAR1,TCAR4(4))
      EQUIVALENCE (IDATM,CHARIN(1)),(CDATM,CAROUT(1))
      LOGICAL*1 TN(256)
      DATA TN /
     . 16*' ', 
     1 16*' ', 
     2 16*' ', 
     3 16*' ', 
     4 11*' ','.','<','(','+','|', 
     5 '&',10*' ','$','*',')',';','', 
     6 '-','/',9*' ',',','%',' ','>','?', 
     7 10*' ',':','#','@','X','=','"', 
     8 ' ','a','b','c','d','e','f','g','h','i',' ','','X','(','+','X',
     9 '_','j','k','l','m','n','o','p','q','r',' ','','X',')','X','X',
     . ' ','X','s','t','u','v','w','x','y','z',' ','X','X','','X','.',
     1 11*' ','X','X','','X','-', 
     2 ' ','A','B','C','D','E','F','G','H','I',6*' ', 
     3 ' ','J','K','L','M','N','O','P','Q','R',6*' ', 
     4 2*' ','S','T','U','V','W','X','Y','Z',6*' ', 
     5 '0','1','2','3','4','5','6','7','8','9',6*' '/ 
      IDATM=IARG1
      DO 1000 I=1,4
         INDEX=0
         TCAR1=CHARIN(I)
         INDEX=INDEX+1
         CAROUT(I)=TN(INDEX)
1000  CONTINUE
      IARG2=CDATM
      RETURN
      END
      SUBROUTINE DMPERR(LINK)
      INTEGER DMPDEV /15/
      IF (LINK.EQ.0) GO TO 9200
      ENTRY DMPER1(LINK)
      IF (ID(LINK).GT.3) GO TO 9100
      RETURN 
C...
C...  The error returns
9100  CONTINUE
      WRITE (DMPDEV,9910) 
      CALL F4TRBK 
9200  CONTINUE 
      WRITE (DMPDEV,9920) 
      CALL F4TRBK 
      RETURN
C...
C...
9920  FORMAT (//' A LIST ELEMENT CONTAINS LNKR OF 0 - LIST STRUCTURE HAS 
     1 APPARENTLY BEEN DESTROYED' / ' PROGRAM TERMINATED'//) 
9910  FORMAT (//' LAST LIST ELEMENT CONTAINS ID FIELD GREATER THAN 3.'/ 
     1 ' IF THIS ELEMENT WAS PREVIOUSLY DUMPED, INVALID LIST STRUCTURE 
     1CAUSED SLIP DUMP ROUTINE TO DUMP THIS ELEMENT TWICE.' 
     1 /' IF NOT PREVIOUSLY DUMPED, ERROR IN PROGRAM CAUSED ILLEGAL ID'/ 
     1 ' PROGRAM TERMINATED'//) 
      END 
      SUBROUTINE F4TRBK
      INTEGER ERRDEV 
      DATA ERRDEV /16/
      WRITE (ERRDEV,00001)
C...  GET THE CHAIN OF CALLS
      CALL TRACER(0)
C...  DUMP THE SLIP MEMORY
      CALL DMPSVM
C...  GO TO MTS
      CALL MTS
C...  IF WE COME BACK DISAPPEAR.....
      CALL SYSTEM
00001 FORMAT (' **** SLIP ERROR ****',/,
     +        'TRACER PACKAGE will be called; options available:'/,
     +        ' respond to the colon prompt character.'/,
     +        '   1.  To obtain a traceback of all subroutine calls',/
     +        '       enter TRACE',/,
     +        '   2.  To yield control to the routine that called',/,
     +        '       the tracer package enter RETURN which will ',/,
     +        '       dump the SLIP data structure on device 15.',/,
     +        '   3.  To yield control to SDS or MTS enter MTS')
      RETURN
      END
      FUNCTION REALS(/ARG/)
      REALS=ARG
      RETURN
      END
      FUNCTION INTGER(/IARG/)
      INTGER=IARG
      RETURN
      END
      INTEGER FUNCTION RSTLST(LSTNM)
      INTEGER RSTDEV/13/,CURLST,ENDS /'ENDS'/
      INTEGER HEAD/'HEAD'/,DATM/'DATM'/,NAME/'NAME'/,ENDL/'ENDL'/
      LOGICAL LTHERE,LDUM
C...  Create the main list
      LSTNM=0
      RSTLST=LIST(LSTNM)
C...  Initialize LTHERE
      IDUMMY=0
      LDUM=LTHERE(IDUMMY,LSTDCT)
C...  Now start reading data from SAVDEV, the first line is junked!
      READ(RSTDEV,9000)KEYIN,DAT,JATTR
      IF(KEYIN.NE.HEAD) CALL F4TRBK
      CURLST=LSTNM
C...  IS THERE AN ATTRIBUTE LIST 
      IF (LNKLW(JATTR).EQ.0) GO TO 1000
      IF (.NOT.LTHERE(JATTR,NUNAME)) CALL F4TRBK
C...  MAKE AN ATTRIBUTE LIST
      IDUM=MAKEDL(NUNAME,CURLST)
1000  CONTINUE
      READ(RSTDEV,9000,END=6000)KEYIN,DAT,JATTR
      IF(KEYIN.EQ.HEAD) GO TO 2000
      IF(KEYIN.EQ.NAME) GO TO 3000
      IF(KEYIN.EQ.DATM) GO TO 4000
      IF(KEYIN.EQ.ENDL) GO TO 5000
      IF (KEYIN.EQ.ENDS) GO TO 6000
2000  CONTINUE
C...     Check to see if the list is already restored or can be restored
         IF(.NOT.LTHERE(DAT,CURLST)) CALL F4TRBK
      IF (LNKLW(JATTR).EQ.0) GO TO 1000
      IF (.NOT.LTHERE(JATTR,NUNAME)) CALL F4TRBK
      IDUM=MAKEDL(NUNAME,CURLST)
C...  ADD ATTRIBUTE LIST IF THERE IS ONE.
         GO TO 1000
3000  CONTINUE
C...     Get NUName of this list
         IF(.NOT.LTHERE(DAT,NUNAME)) CALL F4TRBK
         IDUM=NEWBOT(NUNAME,CURLST)
         GO TO 1000
4000  CONTINUE
         IDUM=NEWBOT(DAT,CURLST)
         GO TO 1000
5000  CONTINUE
         GO TO 1000
6000  CONTINUE
         IDUM=IRALST(LSTDCT)
         GO TO 99999
9000  FORMAT(1X,A4,Z8,Z8)
99999 CONTINUE
         RETURN
      END
      SUBROUTINE SAVLST(LSTNM)
      INTEGER QREAD,FLAG,ENDS /'ENDS'/,SAVDEV /19/
      INTEGER YREAD,SEQRDR
       LOGICAL QTHERE
C...  Make a list of list names saved
      LSTSAV=0
      LSTSAV=LIST(LSTSAV)
      LSTATR=0
      LSTATR=LIST(LSTATR)
C...  Save main list name-its not looked at anyway.
      IDUM=NEWBOT(LSTNM,LSTSAV)
      CALL SAVSEQ(LSTNM,LSTATR)
C...  Appoint structural reader
         QREAD=LRDROV(LSTNM)
C...     Find all lists
1000     CONTINUE
C...        Advance to next name
            NXTLST=INTGER(ADVSNR(QREAD,FLAG))
            IF(FLAG.EQ.-1) GO TO 2000
               IF(QTHERE(NXTLST,LSTSAV)) GO TO 1000
C...              It must be saved
                  IDUM=NEWBOT(NXTLST,LSTSAV)
                  CALL SAVSEQ(NXTLST,LSTATR)
                  GO TO 1000
2000  CONTINUE
C...     APPOINT SEQUENTIAL READER
         YREAD=SEQRDR(LSTATR)
3000     CONTINUE
C...     CHECK TO BE SAVED LIST
         IATTR=INTGER(SEQLR(YREAD,IFLAG))
         IF (IFLAG.EQ.1) GO TO 99999
         IF (QTHERE(IATTR,LSTSAV)) GO TO 3000
C...     SAVE ATTRIBUTE LIST
         IDUM=NEWBOT(IATTR,LSTSAV)
         CALL SAVSEQ(IATTR,LSTATR)
         GO TO 3000
99999 CONTINUE
         IDUM=IRALST(LSTSAV)
         IDUM=IRALST(LSTATR)
         IDUM=IRARDR(QREAD)
         WRITE (SAVDEV,8000) ENDS
8000     FORMAT (' ',A4)
         RETURN
      END
      SUBROUTINE SAVSEQ(SLIST,SAVATR)
      INTEGER SREAD,FLAG,SAVDEV /19/,SLIST,SEQRDR
      INTEGER KEY(4)/'ENDL','DATM','NAME','HEAD'/
      INTEGER SAVATR
      IF(NAMTST(SLIST).NE.0) CALL F4TRBK
C...  A proper list. Appoint a sequential reader
         SREAD=SEQRDR(SLIST)
C...     SEE IF THERE IS AN ATTRIBUTE LIST
         IATR=NAMEDL(SLIST)
         IF (LNKLW(IATR).EQ.0) GO TO 800
C...     PLACE ON LIST. TO BE SAVED.
         IDUM=NEWBOT(IATR,SAVATR)
  800 CONTINUE
         WRITE(SAVDEV,8000)KEY(4),SLIST,IATR
1000     CONTINUE
            DAT=SEQLR(SREAD,FLAG)
            IF(FLAG.EQ.1) GO TO 3000
            WRITE(SAVDEV,8000)KEY(FLAG+3),DAT
            GO TO 1000
3000        CONTINUE
               WRITE(SAVDEV,8000)KEY(1)
               GO TO 99999
8000  FORMAT(' ',A4,Z8,Z8)
99999 CONTINUE
         RETURN
      END
      LOGICAL FUNCTION QTHERE(QDAT,QLIST)
      INTEGER SEQRDR,QREAD,QDAT,QLIST,ITDAT,FLAG
      EQUIVALENCE (TDAT,ITDAT)
C...  Is list empty?
      IF(LISTMT(QLIST).EQ.0) GO TO 3000
C...  Appoint a reader
      QREAD=SEQRDR(QLIST)
1000  CONTINUE
      TDAT=SEQLR(QREAD,FLAG)
      IF(FLAG.EQ.1) GO TO 3000
      IF(QDAT.EQ.ITDAT) GO TO 2000
      GO TO 1000
2000  CONTINUE
         QTHERE=.TRUE.
         GO TO 99999
3000  CONTINUE
         QTHERE=.FALSE.
         GO TO 99999
99999 CONTINUE
         RETURN
      END
      LOGICAL FUNCTION LTHERE(INNAME,NUNAME)
      INTEGER SEQRDR,FLAG
         IF(INNAME.NE.0) GO TO 1000
C...     Make a list of list names restored
            LSTRST=0
            NUNAME=LIST(LSTRST)
            GO TO 99999
1000     CONTINUE
            LREAD=SEQRDR(LSTRST)
2000        CONTINUE
               NUNAME=INTGER(SEQLR(LREAD,FLAG))
               IF(FLAG.EQ.1) GO TO 3000
               INTNAM=INTGER(SEQLR(LREAD,FLAG))
               IF(FLAG.EQ.1) GO TO 4000
            IF (INNAME.EQ.INTNAM) GO TO 5000
               GO TO 2000
3000  CONTINUE
C...     Must be entered into table
         NUNAME=0
         IDUM=LIST(NUNAME)
         IDUM=NEWBOT(NUNAME,LSTRST)
         IDUM=NEWBOT(INNAME,LSTRST)
         LTHERE=.TRUE.
         GO TO 99999
4000  CONTINUE
C...     Something is wrong in the list LSTRST
         NUNAME=0
         LTHERE=.FALSE.
         GO TO 99999
5000  CONTINUE
C...     It has been found
         LTHERE=.TRUE.
         GO TO 99999
99999 CONTINUE
          RETURN
      END
